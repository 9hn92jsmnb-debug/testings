local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local PhysicsService = game:GetService("PhysicsService")
local ChatService = game:GetService("Chat")

local COORD_ROLE_DURATION = 2.25
local VOICE_COOLDOWN = 2.4
local SPOT_COOLDOWN = 4

local VOICE_LIBRARY: { [string]: { string } } = {
	OrderSuppress = {
		"Suppress that target!",
		"Pin them down!",
	},
	OrderFlank = {
		"Flank them now!",
		"Move to their side!",
	},
	OrderAssault = {
		"Push up!",
		"Advance and hit them hard!",
	},
	Confirm = {
		"On it!",
		"Copy!",
	},
	Spot = {
		"Contact spotted!",
		"Eyes on target!",
	},
	Reload = {
		"Reloading!",
		"Cover me, reloading!",
	},
	LastMan = {
		"I'm the last one!",
		"Only me left!",
		"I'm alone here!",
	},
}
export type AnimationTracks = {
	Idle: Animation?,
	Aiming: Animation?,
	Shooting: Animation?,
	Reload: Animation?,
}

export type NPCConfig = {
	FireRate: number?,
	SpreadDegrees: number?,
	BulletSpeed: number?,
	AutoAimDistance: number?,
	MinBurst: number?,
	MaxBurst: number?,
	RepositionDistance: number?,
	RepositionCooldown: number?,
	MaintainDistance: number?,
	AggroDistance: number?,
	StrafeSwitchInterval: number?,
	JukeChance: number?,
	JukeCooldown: number?,
	Animations: AnimationTracks?,
	ReactionTime: number?,
	PeekDuration: number?,
	PeekCooldown: number?,
	SlideChance: number?,
	SlideCooldown: number?,
	SlideDuration: number?,
	SlideSpeed: number?,
	AimOffsetAmount: number?,
	AimLerp: number?,
	MinFlankDistance: number?,
	MaxFlankDistance: number?,
	FlankCooldown: number?,
	SuppressRange: number?,
	SuppressCooldown: number?,
	ReloadThreshold: number?,
	ReloadDuration: number?,
	AccuracyRecovery: number?,
	BurstInaccuracyGrowth: number?,
	BulletSize: Vector3?,
	BulletColor: Color3?,
	Trail: boolean?,
	TrailLifetime: number?,
	TrailWidth: number?,
	CoverSearchRadius: number?,
	CoverHoldTime: number?,
	CoverCooldown: number?,
	SearchDuration: number?,
	SearchRadius: number?,
	SearchAngularSpeed: number?,
	Damage: number?,
}

export type NPCState = {
	Model: Model,
	Root: BasePart?,
	Humanoid: Humanoid?,
	Path: any?,
	Animator: Animator?,
	Gun: Instance?,
	Gunshot: Sound?,
	Target: Model?,
	Config: NPCConfig,
	FireCooldown: number,
	BurstRemaining: number,
	RepositionCooldown: number,
	StrafeTimer: number,
	StrafeDir: number,
	JukeTimer: number,
	CurrentTrack: AnimationTrack?,
	AimVelocity: Vector3,
	SightTimer: number,
	HadLineOfSight: boolean,
	LastSeenPosition: Vector3?,
	LastSeenVelocity: Vector3?,
	ReactionTimer: number,
	PeekTimer: number,
	PeekCooldownTimer: number,
	SlideTimer: number,
	SlideCooldownTimer: number,
	SlideDir: Vector3?,
	FlankTimer: number,
	FlankCooldownTimer: number,
	SuppressTimer: number,
	SuppressCooldownTimer: number,
	ReloadTimer: number,
	Mag: number,
	AccuracyBloom: number,
	CoverTimer: number,
	CoverCooldownTimer: number,
	CoverPosition: Vector3?,
	CoverNormal: Vector3?,
	ShootingTrackTimer: number,
	SearchTimer: number,
	SearchPivot: Vector3?,
	SearchDir: number,
	SearchAngle: number,
	SearchWaypoint: Vector3?,
	SearchPauseTimer: number,
	SearchWanderTimer: number,
	SearchVerifying: boolean,
	StateTag: string,
	FootworkPhase: number,
	MoveBlend: Vector3,
	ActiveOrderFrom: Model?,
	VoiceCooldown: number,
	SpotCooldownTimer: number,
	LastSpottedTarget: Model?,
	ReloadSeekingCover: boolean,
	ReloadCoverWait: number,
	Role: string,
	RoleTimer: number,
	SquadId: number?,
	DiedConn: RBXScriptConnection?
}

local squads: { [number]: { members: { NPCState }, lastManCalled: boolean } } = {}
local nextSquadId = 1
local enemyCandidates: { { Model: Model, Humanoid: Humanoid, Root: BasePart } } = {}
local enemyCandidateMap: { [Model]: { Model: Model, Humanoid: Humanoid, Root: BasePart } } = {}

function isAlive(state: NPCState): boolean
	return state.Humanoid ~= nil and state.Humanoid.Health > 0 and state.Model.Parent ~= nil
end

function isLastMan(state: NPCState): boolean
	if not state.SquadId then
		return false
	end
	local squad = squads[state.SquadId]
	if not squad then
		return false
	end

	local aliveCount = 0
	for _, member in ipairs(squad.members) do
		if isAlive(member) then
			aliveCount += 1
		end
	end

	return aliveCount == 1
end

local m = {}

function createAnimation(id: string): Animation
	local anim = Instance.new("Animation")
	anim.AnimationId = id
	return anim
end

function unwrapConfig(raw: any?): any?
	local value = raw

	if typeof(value) == "Instance" and value:IsA("ModuleScript") then
		local ok, mod = pcall(require, value)
		if ok then
			value = mod
		else
			value = nil
		end
	end

	if typeof(value) ~= "table" then
		return value
	end

	if (value :: any).Config ~= nil then
		return unwrapConfig((value :: any).Config)
	end

	return value
end

function resolveAnimations(animConfig: any?, defaults: AnimationTracks): AnimationTracks
	local resolved: AnimationTracks = {
		Idle = defaults.Idle,
		Aiming = defaults.Aiming,
		Shooting = defaults.Shooting,
		Reload = defaults.Reload,
	}

	local source = unwrapConfig(animConfig)
	if typeof(source) == "table" and (source :: any).Animations ~= nil then
		source = unwrapConfig((source :: any).Animations)
	end

	if typeof(source) == "table" then
		resolved.Idle = normalizeAnimation((source :: any).Idle) or resolved.Idle
		resolved.Aiming = normalizeAnimation((source :: any).Aiming) or resolved.Aiming
		resolved.Shooting = normalizeAnimation((source :: any).Shooting) or resolved.Shooting
		resolved.Reload = normalizeAnimation((source :: any).Reload) or resolved.Reload
	end

	return resolved
end

function playVoiceLine(state: NPCState, key: string)
	if state.VoiceCooldown > 0 then
		return
	end

	if isLastMan(state) then
		key = "LastMan"
	end

	local options = VOICE_LIBRARY[key]
	if not options or #options == 0 then
		return
	end

	local root = state.Root
	if not root or not ChatService then
		return
	end

	local message = options[math.random(1, #options)]
	ChatService:Chat(root, message, Enum.ChatColor.Red)
	state.VoiceCooldown = VOICE_COOLDOWN
end

function targetIsAlive(model: Model?): boolean
	if not model or not model.Parent then
		return false
	end

	local cached = enemyCandidateMap[model]
	if cached then
		return cached.Humanoid.Health > 0 and cached.Model.Parent ~= nil
	end

	local hum = model:FindFirstChildOfClass("Humanoid")
	return hum ~= nil and hum.Health > 0
end

function normalizeAnimation(animation: Animation | string | number | { AnimationId: any } | nil): Animation?
	if animation == nil then
		return nil
	end
	if typeof(animation) == "Instance" then
		local inst = animation :: Instance
		if inst:IsA("Animation") then
			return inst
		end
		return nil
	end
	if typeof(animation) == "table" then
		local animId = (animation :: any).AnimationId
		if animId ~= nil then
			if typeof(animId) == "number" then
				return createAnimation("rbxassetid://" .. tostring(animId))
			elseif typeof(animId) == "string" then
				local numeric = tonumber(animId)
				if numeric ~= nil then
					return createAnimation("rbxassetid://" .. tostring(numeric))
				end
				return createAnimation(animId)
			end
		end
		return nil
	end
	if typeof(animation) == "string" then
		local numeric = tonumber(animation)
		if numeric ~= nil then
			return createAnimation("rbxassetid://" .. tostring(numeric))
		end
		return createAnimation(animation :: string)
	end
	if typeof(animation) == "number" then
		return createAnimation("rbxassetid://" .. tostring(animation :: number))
	end
	return nil
end

local DEFAULT_ANIMATIONS: AnimationTracks = {
	Idle = createAnimation("rbxassetid://98564293923592"),
	Aiming = createAnimation("rbxassetid://117550659743277"),
	Shooting = createAnimation("rbxassetid://109848498488419"),
	Reload = createAnimation("rbxassetid://107885163606729"),
}

local DEFAULTS: NPCConfig = {
	FireRate = 8,
	SpreadDegrees = 4,
	BulletSpeed = 320,
	AutoAimDistance = 180,
	MinBurst = 3,
	MaxBurst = 10,
	RepositionDistance = 24,
	RepositionCooldown = 2,
	MaintainDistance = 78,
	AggroDistance = 120,
	StrafeSwitchInterval = 1.2,
	JukeChance = 0.22,
	JukeCooldown = 1.25,
	ReactionTime = 0.18,
	PeekDuration = 0.75,
	PeekCooldown = 0.85,
	SlideChance = 0.3,
	SlideCooldown = 4,
	SlideDuration = 0.9,
	SlideSpeed = 32,
	AimOffsetAmount = 4,
	AimLerp = 0.2,
	MinFlankDistance = 18,
	MaxFlankDistance = 48,
	FlankCooldown = 5,
	SuppressRange = 110,
	SuppressCooldown = 6,
	ReloadThreshold = 12,
	ReloadDuration = 1.2,
	AccuracyRecovery = 4.3,
	BurstInaccuracyGrowth = 1.3,
	BulletSize = Vector3.new(0.2, 0.2, 1.2),
	BulletColor = Color3.fromRGB(255, 180, 130),
	Trail = true,
	TrailLifetime = 0.22,
	TrailWidth = 0.13,
	CoverSearchRadius = 48,
	CoverHoldTime = 2.35,
	CoverCooldown = 1.5,
	SearchDuration = 3.25,
	SearchRadius = 10,
	SearchAngularSpeed = 1.6,
	Damage = 15,
}

local activeNPCs: { NPCState } = {}
local commanderByTarget: { [Model]: { [number]: NPCState? } } = {}
local postSimConnection: RBXScriptConnection? = nil
local started = false
function assignToSquad(state: NPCState)
	for squadId = 1, nextSquadId - 1 do
		local squad = squads[squadId]
		if squad and #squad.members < 6 then
			table.insert(squad.members, state)
			squad.lastManCalled = false
			state.SquadId = squadId
			return
		end
	end

	local newId = nextSquadId
	nextSquadId += 1
	squads[newId] = { members = { state }, lastManCalled = false }
	state.SquadId = newId
end

function removeFromSquad(state: NPCState)
	if not state.SquadId then
		return
	end
	local squad = squads[state.SquadId]
	if not squad then
		return
	end

	for i = #squad.members, 1, -1 do
		if squad.members[i] == state then
			table.remove(squad.members, i)
		end
	end

	if #squad.members == 0 then
		squads[state.SquadId] = nil
	else
		squad.lastManCalled = false
	end
end

function announceLastManStanding()
	for squadId, squad in pairs(squads) do
		local aliveMembers = {}
		for _, member in ipairs(squad.members) do
			if isAlive(member) then
				table.insert(aliveMembers, member)
			end
		end

		if #aliveMembers > 1 then
			squad.lastManCalled = false
		elseif #aliveMembers == 1 and not squad.lastManCalled and #squad.members > 1 then
			playVoiceLine(aliveMembers[1], "LastMan")
			squad.lastManCalled = true
		end
	end
end

local ignoreParams = OverlapParams.new()
ignoreParams.FilterType = Enum.RaycastFilterType.Blacklist

function isNPCModel(model: Model?): boolean
	if not model then
		return false
	end
	for _, state in ipairs(activeNPCs) do
		if state.Model == model then
			return true
		end
	end
	return false
end

function loadModelConfig(model: Model, configOverride: any?): any?
	if configOverride then
		local overridden = unwrapConfig(configOverride)
		if typeof(overridden) == "table" then
			return overridden
		end
	end

	local preferred: ModuleScript? = model:FindFirstChild("Configuration")
		or model:FindFirstChild("Config")
		or model:FindFirstChildWhichIsA("ModuleScript")

	if preferred and preferred:IsA("ModuleScript") then
		local ok, moduleConfig = pcall(require, preferred)
		if ok then
			local unwrapped = unwrapConfig(moduleConfig)
			if typeof(unwrapped) == "table" then
				return unwrapped
			end
		end
	end

	for _, child in ipairs(model:GetDescendants()) do
		if child:IsA("ModuleScript") and child ~= preferred then
			local ok, moduleConfig = pcall(require, child)
			if ok then
				local unwrapped = unwrapConfig(moduleConfig)
				if typeof(unwrapped) == "table" then
					return unwrapped
				end
			end
		end
	end

	return nil
end

function refreshEnemyCandidates()
	enemyCandidates = {}
	enemyCandidateMap = {}

	for _, descendant in ipairs(workspace:GetDescendants()) do
		if descendant:IsA("Humanoid") and descendant.Health > 0 then
			local char = descendant.Parent
			if char and char:IsA("Model") and not isNPCModel(char) then
				if char:GetAttribute("NPC") then
					continue
				end
				local hrp = char:FindFirstChild("HumanoidRootPart")
				if hrp then
					local entry = {
						Model = char,
						Humanoid = descendant,
						Root = hrp,
					}
					table.insert(enemyCandidates, entry)
					enemyCandidateMap[char] = entry
				end
			end
		end
	end
end
function bindDeath(state: NPCState)
	if state.Humanoid and not state.DiedConn then
		state.DiedConn = state.Humanoid.Died:Connect(function()
			doRagdollFrom(state.Model)
			m.RemoveNPC(state.Model)
		end)
	end
end
function blendConfigs(config: NPCConfig?): NPCConfig
	local source = unwrapConfig(config)
	local cfgTable = typeof(source) == "table" and source or {}

	if typeof(cfgTable) == "table" and (cfgTable :: any).Config ~= nil then
		local unwrapped = unwrapConfig((cfgTable :: any).Config)
		if typeof(unwrapped) == "table" then
			cfgTable = unwrapped
		end
	end

	local result: NPCConfig = {}
	for key, defaultValue in pairs(DEFAULTS) do
		local value = (cfgTable :: any)[key]
		result[key] = value ~= nil and value or defaultValue
	end

	result.Animations = resolveAnimations((cfgTable :: any).Animations, DEFAULT_ANIMATIONS)
	return result
end

function stopTrack(state: NPCState)
	if state.CurrentTrack then
		state.CurrentTrack:Stop(0.1)
		state.CurrentTrack = nil
	end
end
function doRagdollFrom(npc: Model)
	local Dummy = npc
	if not Dummy or not Dummy.Parent then return end

	local zombiecorpse = Dummy:Clone()
	Dummy:Destroy()
	zombiecorpse.Parent = workspace
	for _, d in ipairs(zombiecorpse:GetDescendants()) do
		if d:IsA("Script") or d:IsA("LocalScript") then d:Destroy() end
	end
	game.Debris:AddItem(zombiecorpse, 15)
	local Humanoid = zombiecorpse:FindFirstChildOfClass("Humanoid")
	local Torso = zombiecorpse:FindFirstChild("Torso")
	if not Humanoid or not Torso then return end
	Humanoid.PlatformStand = true
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
	for _,v in pairs(Torso:GetChildren()) do
		if v.ClassName == 'Motor6D' or v.ClassName == 'Weld' then v:Destroy() end
	end
	for _,v in pairs(zombiecorpse:GetChildren()) do
		if v.ClassName == "Part" then
			for _,w in pairs(v:GetChildren()) do
				if w.ClassName == "BodyPosition" or w.ClassName == "BodyVelocity" then w:Destroy() end
			end
		end
	end
	local function makeconnections(limb, a0, a1, tl, tu)
		local c = Instance.new('BallSocketConstraint', limb)
		c.LimitsEnabled = true
		c.Attachment0 = a0
		c.Attachment1 = a1
		c.TwistLimitsEnabled = true
		c.TwistLowerAngle = tl
		c.TwistUpperAngle = tu
		c.UpperAngle = 70
	end
	local function makehingeconnections(limb, a0, a1, low, up)
		local c = Instance.new('HingeConstraint', limb)
		c.Attachment0 = a0
		c.Attachment1 = a1
		c.LimitsEnabled = true
		c.LowerAngle = low
		c.UpperAngle = up
	end
	Humanoid.Parent['Right Arm'].RightShoulderAttachment.Position = Vector3.new(0, 0.5, 0)
	Torso.RightCollarAttachment.Position = Vector3.new(1.5, 0.5, 0)
	Humanoid.Parent['Left Arm'].LeftShoulderAttachment.Position = Vector3.new(0, 0.5, 0)
	Torso.LeftCollarAttachment.Position = Vector3.new(-1.5, 0.5, 0)
	local RightLegAttachment = Instance.new("Attachment", Humanoid.Parent["Right Leg"]); RightLegAttachment.Position = Vector3.new(0, 1, 0)
	local TorsoRightLegAttachment = Instance.new("Attachment", Torso); TorsoRightLegAttachment.Position = Vector3.new(0.5, -1, 0)
	local LeftLegAttachment = Instance.new("Attachment", Humanoid.Parent["Left Leg"]); LeftLegAttachment.Position = Vector3.new(0, 1, 0)
	local TorsoLeftLegAttachment = Instance.new("Attachment", Torso); TorsoLeftLegAttachment.Position = Vector3.new(-0.5, -1, 0)
	if Humanoid.Parent:FindFirstChild("Head") then
		local HeadAttachment = Instance.new("Attachment", Humanoid.Parent.Head)
		HeadAttachment.Position = Vector3.new(0, -0.5, 0)
		makehingeconnections(Humanoid.Parent.Head, HeadAttachment, Torso.NeckAttachment, -20, 20)
	end
	makeconnections(Humanoid.Parent['Right Arm'], Humanoid.Parent['Right Arm'].RightShoulderAttachment, Torso.RightCollarAttachment, -80, 80)
	makeconnections(Humanoid.Parent['Left Arm'], Humanoid.Parent['Left Arm'].LeftShoulderAttachment, Torso.LeftCollarAttachment, -80, 80)
	makeconnections(Humanoid.Parent['Right Leg'], RightLegAttachment, TorsoRightLegAttachment, -80, 80)
	makeconnections(Humanoid.Parent['Left Leg'], LeftLegAttachment, TorsoLeftLegAttachment, -80, 80)
	local function addLimbCollider(limbName)
		local limb = Humanoid.Parent:FindFirstChild(limbName)
		if not limb then return end
		local limbcollider = Instance.new("Part", limb)
		limbcollider.Size = Vector3.new(1,1.3,1)
		limbcollider.Shape = Enum.PartType.Cylinder
		limbcollider.Transparency = 1
		local limbcolliderweld = Instance.new("Weld", limbcollider)
		limbcolliderweld.Part0 = limb
		limbcolliderweld.Part1 = limbcollider
		limbcolliderweld.C0 = CFrame.fromEulerAnglesXYZ(0,0,math.pi/2) * CFrame.new(-0.4,0,0)
		for _,v in pairs(limb:GetChildren()) do
			if v.ClassName == 'Motor6D' or v.ClassName == 'Weld' then v:Destroy() end
		end
	end
	addLimbCollider("Right Arm")
	addLimbCollider("Left Arm")
	addLimbCollider("Left Leg")
	addLimbCollider("Right Leg")
	if zombiecorpse:FindFirstChild("HumanoidRootPart") then
		zombiecorpse.HumanoidRootPart.CanCollide = false
		zombiecorpse.HumanoidRootPart:Destroy()
	end
end
function playTrack(state: NPCState, animation: Animation?, shouldLoop: boolean?)
	if not state.Animator or not animation then
		return
	end

	local desiredLoop = shouldLoop ~= nil and shouldLoop or false
	if state.CurrentTrack and state.CurrentTrack.Animation == animation then
		state.CurrentTrack.Looped = desiredLoop
		if not state.CurrentTrack.IsPlaying then
			state.CurrentTrack:Play(0.12, 1, 1)
		end
		return
	end

	stopTrack(state)
	local track = state.Animator:LoadAnimation(animation)
	track.Priority = Enum.AnimationPriority.Action
	track.Looped = desiredLoop
	track:Play(0.12, 1, 1)
	state.CurrentTrack = track
end

function lerp(a: Vector3, b: Vector3, t: number): Vector3
	return a + (b - a) * t
end

function clamp01(v: number): number
	if v < 0 then
		return 0
	elseif v > 1 then
		return 1
	end
	return v
end

function makeSpreadDirection(base: Vector3, spreadDegrees: number, bloom: number): Vector3
	local cf = CFrame.lookAt(Vector3.zero, base)
	local spreadRad = math.rad(spreadDegrees * bloom)
	local yaw = (math.random() * 2 - 1) * spreadRad
	local pitch = (math.random() * 2 - 1) * spreadRad * 0.6
	local offset = CFrame.Angles(pitch, yaw, 0)
	return (cf * offset).LookVector
end

function spawnTrail(part: BasePart, direction: Vector3, config: NPCConfig)
	if not config.Trail then
		return
	end

	local attachment0 = Instance.new("Attachment")
	attachment0.Position = Vector3.zero
	attachment0.Parent = part

	local attachment1 = Instance.new("Attachment")
	attachment1.Position = direction.Unit * 1
	attachment1.Parent = part

	local trail = Instance.new("Trail")
	trail.Attachment0 = attachment0
	trail.Attachment1 = attachment1
	trail.Color = ColorSequence.new(config.BulletColor)
	trail.Lifetime = config.TrailLifetime or 0.2
	trail.MinLength = 0.1
	trail.Transparency = NumberSequence.new(0.15, 1)
	trail.LightEmission = 0.8
	trail.FaceCamera = true
	trail.WidthScale = NumberSequence.new(config.TrailWidth or 0.1)
	trail.Parent = part

	Debris:AddItem(attachment0, config.TrailLifetime or 0.2)
	Debris:AddItem(attachment1, config.TrailLifetime or 0.2)
	Debris:AddItem(trail, config.TrailLifetime or 0.2)
end
function playGunshot(shooter: NPCState, origin: BasePart?)
	local template = shooter.Gunshot
	if not template then
		return
	end

	local parent: Instance? = origin or template.Parent or shooter.Gun
	if not parent then
		return
	end

	local sound = template:Clone()
	sound.Parent = parent
	sound:Play()
	local cleanupDelay = (sound.TimeLength and sound.TimeLength > 0 and sound.TimeLength or 1) + 0.35
	Debris:AddItem(sound, cleanupDelay)
end
function spawnBullet(from: BasePart, direction: Vector3, speed: number, config: NPCConfig, shooter: NPCState)
	playGunshot(shooter, from)
	local bullet = Instance.new("Part")
	bullet.Size = config.BulletSize or Vector3.new(0.2, 0.2, 1.2)
	bullet.Material = Enum.Material.Neon
	bullet.Color = config.BulletColor or Color3.fromRGB(255, 180, 130)
	bullet.CanCollide = false
	bullet.CanTouch = false
	bullet.CollisionGroup = "Bullets"
	bullet.Parent = workspace

	local dir = direction.Unit
	local pos = from.Position
	bullet.CFrame = CFrame.lookAt(pos, pos + dir)

	spawnTrail(bullet, direction, config)

	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Blacklist
	params.FilterDescendantsInstances = { shooter.Model, bullet }

	local lifetime = 4
	local age = 0
	local conn
	conn = RunService.Heartbeat:Connect(function(dt)
		if not bullet.Parent then
			if conn then conn:Disconnect() end
			return
		end
		age += dt
		if age >= lifetime then
			if conn then conn:Disconnect() end
			bullet:Destroy()
			return
		end

		local remaining = dt
		local substep = 1/240
		while remaining > 0 do
			local stepDt = math.min(remaining, substep)
			local stepVec = dir * speed * stepDt
			local hit = workspace:Raycast(pos, stepVec, params)

			if hit then
				local hitModel = hit.Instance:FindFirstAncestorOfClass("Model")
				if hitModel and (hitModel == shooter.Model or isNPCModel(hitModel)) then
					pos = hit.Position + dir * 0.02
					bullet.CFrame = CFrame.lookAt(pos, pos + dir)
					params.FilterDescendantsInstances = { shooter.Model, bullet }
				else
					if hitModel then
						local hum = hitModel:FindFirstChildOfClass("Humanoid")
						if hum and hum.Health > 0 then
							hum:TakeDamage(config.Damage or DEFAULTS.Damage)
						end
					end
					bullet.CFrame = CFrame.lookAt(hit.Position, hit.Position + dir)
					if conn then conn:Disconnect() end
					bullet:Destroy()
					return
				end
			else
				pos += stepVec
				bullet.CFrame = CFrame.lookAt(pos, pos + dir)
			end

			remaining -= stepDt
		end
	end)

	Debris:AddItem(bullet, lifetime)
end

function computeAimOrigin(state: NPCState): BasePart?
	if state.Gun then
		if state.Gun:IsA("Model") then
			local primary = state.Gun.PrimaryPart or state.Gun:FindFirstChildWhichIsA("BasePart")
			if primary then
				return primary
			end
		elseif state.Gun:IsA("Tool") then
			local handle = state.Gun:FindFirstChildWhichIsA("BasePart")
			if handle then
				return handle
			end
		end
	end
	return state.Root
end



function isFiniteVector3(v)
	return v
		and v.X == v.X
		and v.Y == v.Y
		and v.Z == v.Z
		and math.abs(v.X) < math.huge
		and math.abs(v.Y) < math.huge
		and math.abs(v.Z) < math.huge
end

function chooseBestDirection(origin, baseDir, params, probe)
	local candidates = {}

	function addCandidate(dir, weight)
		local hit = workspace:Raycast(origin, dir * probe, params)
		local distance = hit and hit.Distance or probe
		local normal = hit and hit.Normal or Vector3.zero
		table.insert(candidates, {
			dir = dir,
			distance = distance,
			normal = normal,
			weight = weight or 1,
			hit = hit,
		})
	end

	addCandidate(baseDir, 1)
	local right = Vector3.new(baseDir.Z, 0, -baseDir.X)
	local left = -right

	addCandidate((baseDir + right * 0.5).Unit, 0.9)
	addCandidate((baseDir + left * 0.5).Unit, 0.9)
	addCandidate((baseDir + right).Unit, 0.75)
	addCandidate((baseDir + left).Unit, 0.75)

	local best = candidates[1]
	for i = 2, #candidates do
		local c = candidates[i]
		local clearanceScore = c.distance * c.weight
		local bestScore = best.distance * best.weight
		if clearanceScore > bestScore then
			best = c
		end
	end

	return best
end

function buildEngagementGroups(): { [Model]: { [number]: { NPCState } } }
	local groups: { [Model]: { [number]: { NPCState } } } = {}
	for _, state in ipairs(activeNPCs) do
		local targetModel = state.Target
		if targetModel and targetIsAlive(targetModel) and isAlive(state) and state.SquadId then
			groups[targetModel] = groups[targetModel] or {}
			local squadGroups = groups[targetModel]
			squadGroups[state.SquadId] = squadGroups[state.SquadId] or {}
			table.insert(squadGroups[state.SquadId], state)
		else
			if state.Target and not targetIsAlive(state.Target) then
				state.Target = nil
				state.LastSeenPosition = nil
				state.LastSeenVelocity = nil
				state.LastSpottedTarget = nil
			end
		end
	end
	return groups
end

function pickCommander(group: { NPCState }, targetModel: Model): NPCState?
	local commander: NPCState? = nil
	local commanderScore = -math.huge
	local targetRoot = targetModel:FindFirstChild("HumanoidRootPart")

	for _, state in ipairs(group) do
		if state.Humanoid and state.Humanoid.Health > 0 and state.Root then
			local distance = targetRoot and (state.Root.Position - targetRoot.Position).Magnitude or 0
			local score = state.Mag * 0.6 + (state.HadLineOfSight and 8 or 0) - distance * 0.05
			if score > commanderScore then
				commanderScore = score
				commander = state
			end
		end
	end

	return commander
end

function purgeStaleCommander(targetModel: Model, squadId: number, group: { NPCState }): NPCState?
	local cachedBySquad = commanderByTarget[targetModel]
	if not cachedBySquad then
		return nil
	end
	local cached = cachedBySquad[squadId]
	if not cached then
		return nil
	end

	for _, member in ipairs(group) do
		if member == cached and isAlive(member) then
			return cached
		end
	end

	cachedBySquad[squadId] = nil
	return nil
end

function getCommanderForTarget(targetModel: Model, squadId: number, group: { NPCState }): NPCState?
	local cached = purgeStaleCommander(targetModel, squadId, group)
	if cached then
		return cached
	end

	local commander = pickCommander(group, targetModel)
	commanderByTarget[targetModel] = commanderByTarget[targetModel] or {}
	commanderByTarget[targetModel][squadId] = commander
	return commander
end

function pruneUnusedCommanders(groups: { [Model]: { [number]: { NPCState } } })
	for targetModel, squadMap in pairs(commanderByTarget) do
		if not groups[targetModel] then
			commanderByTarget[targetModel] = nil
		else
			for squadId in pairs(squadMap) do
				if not groups[targetModel][squadId] then
					squadMap[squadId] = nil
				end
			end
		end
	end
end

function issueOrder(commander: NPCState, recipient: NPCState, role: string)
	local normalized = role
	if role == "Suppress" then
		normalized = "Suppressor"
	elseif role == "Flank" then
		normalized = "Flanker"
	end

	recipient.Role = normalized
	recipient.RoleTimer = COORD_ROLE_DURATION
	recipient.ActiveOrderFrom = commander.Model

	if commander ~= recipient then
		local orderKey = "Order" .. role
		playVoiceLine(commander, orderKey)
		playVoiceLine(recipient, "Confirm")
	else
		playVoiceLine(commander, "Order" .. role)
	end
end

function shouldRefreshOrders(group: { NPCState }): boolean
	for _, state in ipairs(group) do
		if state.RoleTimer <= 0 then
			return true
		end
	end
	return false
end

function assignCoordinatedRoles(group: { NPCState }, targetModel: Model, squadId: number)
	if #group == 0 then
		return
	end

	local cachedCommander = purgeStaleCommander(targetModel, squadId, group)
	local needsRefresh = shouldRefreshOrders(group) or cachedCommander == nil
	if not needsRefresh then
		return
	end

	local commander = cachedCommander or getCommanderForTarget(targetModel, squadId, group)
	if not commander then
		return
	end

	local targetRoot = targetModel:FindFirstChild("HumanoidRootPart")
	local suppressor: NPCState? = nil
	local suppressorMag = -math.huge
	for _, state in ipairs(group) do
		if state.Mag > suppressorMag and state ~= commander then
			suppressorMag = state.Mag
			suppressor = state
		end
	end

	local flanker: NPCState? = nil
	local flankerScore = -math.huge
	for _, state in ipairs(group) do
		if state ~= suppressor and state ~= commander and targetRoot and state.Root then
			local distanceScore = (state.Root.Position - targetRoot.Position).Magnitude
			if distanceScore > flankerScore then
				flankerScore = distanceScore
				flanker = state
			end
		end
	end

	for _, state in ipairs(group) do
		if state == suppressor then
			issueOrder(commander, state, "Suppress")
		elseif state == flanker then
			issueOrder(commander, state, "Flank")
		else
			issueOrder(commander, state, "Assault")
		end
	end
end

function setMovement(state, move)
	local humanoid = state and state.Humanoid
	if not humanoid then
		return
	end
	if not isFiniteVector3(move) or move.Magnitude < 0.001 then
		humanoid:Move(Vector3.zero, false)
		return
	end

	local character = state.Model or humanoid.Parent
	local root = character and character:FindFirstChild("HumanoidRootPart")
	if not root then
		humanoid:Move(move.Unit, false)
		return
	end

	local dir = Vector3.new(move.X, 0, move.Z)
	if dir.Magnitude < 1e-4 then
		humanoid:Move(move.Unit, false)
		return
	end
	dir = dir.Unit

	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Exclude
	params.FilterDescendantsInstances = { character }

	local origin = root.Position + Vector3.new(0, 2, 0)
	local minClear = 1.25
	local probe = math.max(6, minClear + 4)

	local forwardHit = workspace:Raycast(origin, dir * probe, params)
	if forwardHit then
		local n = Vector3.new(forwardHit.Normal.X, 0, forwardHit.Normal.Z)
		local facing = n.Magnitude > 0 and n:Dot(dir) / n.Magnitude or 0

		if forwardHit.Distance <= minClear and facing < -0.1 then
			local away = (-n).Magnitude > 1e-3 and (-n).Unit or dir
			local slide = dir - n * dir:Dot(n)
			slide = Vector3.new(slide.X, 0, slide.Z)
			local hasSlide = slide.Magnitude > 1e-3
			local t = math.clamp((minClear - forwardHit.Distance) / minClear, 0, 1)
			local adjusted = (away * (0.6 + 0.4 * t))
				+ ((hasSlide and slide.Unit or Vector3.new(dir.Z, 0, -dir.X)) * (0.4 - 0.2 * t))
			humanoid:Move(adjusted.Unit, false)
			return
		elseif facing < -0.25 then
			local slide = dir - n * dir:Dot(n)
			slide = Vector3.new(slide.X, 0, slide.Z)
			if slide.Magnitude > 1e-3 then
				humanoid:Move(slide.Unit, false)
				return
			else
				local perp = Vector3.new(dir.Z, 0, -dir.X)
				humanoid:Move(perp.Unit, false)
				return
			end
		end
	end

	if forwardHit and forwardHit.Distance <= probe * 0.5 then
		local best = chooseBestDirection(origin, dir, params, probe)
		if best then
			local movementDir = best.dir
			if best.hit and math.abs(best.normal.Y) < 0.6 then
				local n = Vector3.new(best.normal.X, 0, best.normal.Z)
				local slide = movementDir - n * movementDir:Dot(n)
				slide = Vector3.new(slide.X, 0, slide.Z)
				if slide.Magnitude > 1e-3 then
					movementDir = slide.Unit
				end
			end
			humanoid:Move(movementDir, false)
			return
		end
	end

	humanoid:Move(move.Unit, false)
end
function tagCharacter(model: Model)
	for _, part in ipairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			PhysicsService:SetPartCollisionGroup(part, "NPC")
		end
	end
end

function refreshAttachments(state: NPCState)
	local gunValue = state.Model:FindFirstChild("Gun")
	local gunInstance = gunValue and gunValue:IsA("ObjectValue") and gunValue.Value or nil
	state.Gun = gunInstance
	state.Gunshot = nil

	if gunInstance then
		local Shoot = gunInstance:FindFirstChildWhichIsA("Sound")
		state.Gunshot = Shoot
	else
		state.Gunshot = nil
	end
end

function predictTargetPosition(targetRoot: BasePart, lastVel: Vector3?, bulletSpeed: number, origin: Vector3): Vector3
	local targetPos = targetRoot.Position
	if not lastVel then
		return targetPos
	end

	local toTarget = targetPos - origin
	local distance = toTarget.Magnitude
	local time = distance / bulletSpeed
	return targetPos + lastVel * time
end

function recordSight(state: NPCState, targetRoot: BasePart)
	state.LastSeenPosition = targetRoot.Position
	state.LastSeenVelocity = targetRoot.AssemblyLinearVelocity
	state.SightTimer = 1.2
	state.SearchTimer = 0
	state.SearchVerifying = false

	local targetModel = targetRoot:FindFirstAncestorOfClass("Model")
	local isNewTarget = targetModel and targetModel ~= state.LastSpottedTarget
	if isNewTarget or state.SpotCooldownTimer <= 0 then
		playVoiceLine(state, "Spot")
		state.SpotCooldownTimer = SPOT_COOLDOWN
		state.LastSpottedTarget = targetModel
	end
end

function computeSuppressIntent(state: NPCState, distance: number)
	if distance > state.Config.SuppressRange then
		return false
	end
	if state.SuppressCooldownTimer > 0 then
		return false
	end
	if state.SuppressTimer > 0 then
		return true
	end
	if math.random() < 0.25 then
		state.SuppressTimer = 1 + math.random() * 0.5
		state.SuppressCooldownTimer = state.Config.SuppressCooldown
		return true
	end
	return false
end

function pickFlank(state: NPCState, desiredDir: Vector3): Vector3
	if state.FlankCooldownTimer > 0 then
		return desiredDir
	end

	if math.random() < 0.35 then
		local rot = math.rad(math.random(40, 75))
		local dir = desiredDir
		if math.random() > 0.5 then
			rot = -rot
		end
		local cf = CFrame.fromAxisAngle(Vector3.new(0, 1, 0), rot)
		dir = (cf.LookVector * dir.Magnitude).Unit
		state.FlankCooldownTimer = state.Config.FlankCooldown
		state.FlankTimer = 0.8 + math.random() * 0.4
		return dir
	end

	return desiredDir
end

function chooseSlide(state: NPCState, strafeDir: Vector3): Vector3?
	if state.SlideCooldownTimer > 0 then
		return nil
	end
	if math.random() > state.Config.SlideChance then
		return nil
	end
	state.SlideCooldownTimer = state.Config.SlideCooldown
	state.SlideTimer = state.Config.SlideDuration
	state.MoveBlend = state.MoveBlend + strafeDir * 2
	return strafeDir * state.Config.SlideSpeed
end

function computeAimOffset(state: NPCState): Vector3
	local wobble = Vector3.new(
		math.sin(state.FootworkPhase * 3.1),
		math.cos(state.FootworkPhase * 2.1),
		math.sin(state.FootworkPhase * 2.7)
	)
	return wobble * (state.Config.AimOffsetAmount or 4)
end

function findCoverPosition(state: NPCState, targetRoot: BasePart): (Vector3?, Vector3?)
	local root = state.Root
	if not root then return nil end

	local radius = state.Config.CoverSearchRadius or 28
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Blacklist
	params.FilterDescendantsInstances = { state.Model, targetRoot.Parent }

	local origin = root.Position + Vector3.new(0, 2.2, 0)
	local toTarget = (targetRoot.Position - origin)

	local bestPos: Vector3? = nil
	local bestNormal: Vector3? = nil
	local bestScore = math.huge

	local function isHumanoidModel(inst: Instance?): boolean
		if not inst then return false end
		local m = inst:FindFirstAncestorOfClass("Model")
		return m ~= nil and m:FindFirstChildOfClass("Humanoid") ~= nil
	end

	local function raycastIgnoringHumanoids(from: Vector3, dir: Vector3): RaycastResult?
		local r = workspace:Raycast(from, dir, params)
		if r and isHumanoidModel(r.Instance) then
			return nil
		end
		return r
	end

	local function visible(from: Vector3): boolean
		local r = raycastIgnoringHumanoids(from, targetRoot.Position - from)
		return not r or r.Instance:IsDescendantOf(targetRoot.Parent)
	end

	local function eval(hit: RaycastResult)
		if not hit or isHumanoidModel(hit.Instance) then return end
		local n = hit.Normal
		if math.abs(n.Y) > 0.35 then return end

		local wallN = Vector3.new(n.X, 0, n.Z).Unit
		local standBack = 3
		local standPosGuess = hit.Position + wallN * standBack

		local ground = raycastIgnoringHumanoids(standPosGuess + Vector3.new(0, 6, 0), Vector3.new(0, -14, 0))
		if not ground then return end

		local groundN = ground.Normal
		if groundN.Y < 0.85 then return end

		local coverPos = ground.Position + Vector3.new(0, 2.6, 0)

		local headClearTop = raycastIgnoringHumanoids(coverPos + Vector3.new(0, 0.5, 0), Vector3.new(0, 3.0, 0))
		if headClearTop then return end

		local thicknessProbe = raycastIgnoringHumanoids(hit.Position + wallN * 0.5, wallN * 3.0)
		local thickness = thicknessProbe and thicknessProbe.Distance or 3.0

		local peekHeight = 1.5
		local peekFrom = coverPos + Vector3.new(0, peekHeight, 0)

		local block = raycastIgnoringHumanoids(peekFrom, targetRoot.Position - peekFrom)
		if not block or block.Instance:IsDescendantOf(targetRoot.Parent) or math.abs(block.Normal.Y) > 0.35 then
			return
		end

		local tangent = Vector3.new(wallN.Z, 0, -wallN.X)
		local peekOffset = 1.6
		local leftPeek = peekFrom + tangent * peekOffset
		local rightPeek = peekFrom - tangent * peekOffset

		local leftBlocked = not visible(leftPeek)
		local rightBlocked = not visible(rightPeek)

		local leftCanPeek = not leftBlocked
		local rightCanPeek = not rightBlocked
		local canPeek = leftCanPeek or rightCanPeek
		if not canPeek then return end

		local blockStrength = 0
		do
			local samples = 3
			for i = 1, samples do
				local jitter = Vector3.new((math.random() * 2 - 1) * 0.6, (math.random() * 2 - 1) * 0.4, (math.random() * 2 - 1) * 0.6)
				local p = peekFrom + jitter
				local r = raycastIgnoringHumanoids(p, targetRoot.Position - p)
				if r and (not r.Instance:IsDescendantOf(targetRoot.Parent)) and math.abs(r.Normal.Y) < 0.6 then
					blockStrength += 1
				end
			end
			blockStrength = blockStrength / 3
		end

		local distanceScore = (coverPos - root.Position).Magnitude
		local facingScore = math.max(0, wallN:Dot((-toTarget).Unit))
		local thicknessScore = math.clamp(thickness, 0, 3)
		local exposureScore = 1 - blockStrength

		local score =
			distanceScore * 1.0
		- facingScore * 8.0
		- thicknessScore * 1.5
			+ exposureScore * 6.0
			+ (leftCanPeek and 0 or 1.5)
			+ (rightCanPeek and 0 or 1.5)

		if score < bestScore then
			bestScore = score
			bestPos = coverPos
			bestNormal = wallN
		end
	end

	local steps = 48
	for i = 1, steps do
		local angle = math.rad((i / steps) * 360) + math.rad(math.random(-4, 4))
		local dir = CFrame.fromAxisAngle(Vector3.new(0, 1, 0), angle).LookVector
		local hit = raycastIgnoringHumanoids(origin, dir * radius)
		if hit and hit.Instance and not hit.Instance:IsDescendantOf(state.Model) then
			eval(hit)
		end
	end

	for _ = 1, 14 do
		local jitter = Vector3.new(math.random() * 2 - 1, 0, math.random() * 2 - 1)
		local probeOrigin = origin + jitter * 3
		local d = (targetRoot.Position - probeOrigin).Unit
		d = CFrame.fromAxisAngle(Vector3.new(0, 1, 0), math.rad(math.random(-70, 70))):VectorToWorldSpace(d)
		local hit = raycastIgnoringHumanoids(probeOrigin, d * radius)
		if hit and hit.Instance and not hit.Instance:IsDescendantOf(state.Model) then
			eval(hit)
		end
	end

	return bestPos, bestNormal
end
function shouldTakeCover(state: NPCState, distance: number): boolean
	if state.CoverCooldownTimer > 0 then
		return false
	end

	local needsReloadCover = state.ReloadTimer > 0 or state.Mag < state.Config.ReloadThreshold
	if needsReloadCover then
		return true
	end

	if state.ReloadTimer > 0 or state.Mag < state.Config.ReloadThreshold then
		return true
	end

	if distance < state.Config.MaintainDistance - 4 then
		return true
	end

	if state.SuppressTimer > 0 then
		return true
	end

	if state.HadLineOfSight and state.PeekTimer <= 0 and state.PeekCooldownTimer <= 0 then
		return true
	end

	local baseChance = state.HadLineOfSight and 0.5 or 0.3
	local lowMagBonus = math.clamp((state.Config.ReloadThreshold - math.max(state.Mag, 0)) * 0.03, 0, 0.25)
	return math.random() < (baseChance + lowMagBonus)
end

function isInCover(state: NPCState): boolean
	if not state.Root then
		return false
	end
	if state.CoverPosition then
		local distance = (state.Root.Position - state.CoverPosition).Magnitude
		if state.CoverTimer > 0 or distance < 3 then
			return true
		end
	end
	return false
end

function pickTarget(state: NPCState)
	local root = state.Root
	if not root then
		return
	end

	local origin = computeAimOrigin(state) or root
	local function scoreTarget(hrp: BasePart, hasLOS: boolean): number
		local dist = (hrp.Position - root.Position).Magnitude
		local losBonus = hasLOS and 1000 or 0
		return losBonus - dist
	end

	local best: Model? = nil
	local bestScore = -math.huge

	if targetIsAlive(state.Target) then
		local cached = enemyCandidateMap[state.Target]
		local hrp = cached and cached.Root or state.Target:FindFirstChild("HumanoidRootPart")
		if hrp then
			local dist = (hrp.Position - root.Position).Magnitude
			local withinRange = dist <= state.Config.AutoAimDistance * 1.1
			if withinRange then
				local hasLOS = hasLineOfSight(origin, hrp, state.Model)
				best = state.Target
				bestScore = scoreTarget(hrp, hasLOS)
			end
		end
	end

	for _, candidate in ipairs(enemyCandidates) do
		if candidate.Model ~= state.Model then
			local hrp = candidate.Root
			local dist = (hrp.Position - root.Position).Magnitude
			if dist < state.Config.AutoAimDistance then
				local hasLOS = hasLineOfSight(origin, hrp, state.Model)
				local candidateScore = scoreTarget(hrp, hasLOS)
				if candidateScore > bestScore then
					best = candidate.Model
					bestScore = candidateScore
				end
			end
		end
	end

	if best ~= state.Target then
		local previousTarget = state.Target
		state.Target = best
		if not best then
			state.LastSeenPosition = nil
			state.LastSeenVelocity = nil
		end

		if previousTarget ~= best and state.Mag <= math.max(1, state.Config.ReloadThreshold) then
			state.ReloadSeekingCover = true
			state.ReloadCoverWait = 0
			reloadIfNeeded(state)
		end
	end
end

function hasLineOfSight(origin: BasePart, target: BasePart, model: Model): boolean
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Blacklist
	params.FilterDescendantsInstances = { model }
	local result = workspace:Raycast(origin.Position, (target.Position - origin.Position), params)
	return not result or result.Instance:IsDescendantOf(target.Parent)
end

function driveFacing(state: NPCState, lookPos: Vector3)
	local root = state.Root
	if not root then
		return
	end
	local flatLook = Vector3.new(lookPos.X, root.Position.Y, lookPos.Z)
	if (flatLook - root.Position).Magnitude < 0.01 then
		return
	end
	root.CFrame = CFrame.lookAt(root.Position, flatLook)
end

function pickSearchWaypoint(state: NPCState, pivot: Vector3)
	local root = state.Root
	if not root then
		return
	end

	local radius = state.Config.SearchRadius or 10
	local toPivot = pivot - root.Position
	local forward = if toPivot.Magnitude < 1 then root.CFrame.LookVector else toPivot.Unit
	local lateral = Vector3.new(forward.Z, 0, -forward.X) * state.SearchDir

	state.SearchAngle += state.Config.SearchAngularSpeed * state.SearchDir
	local arcScale = 0.55 + math.clamp(math.abs(math.sin(state.SearchAngle)), 0, 0.35)
	local forwardOffset = forward * (radius * math.random(-0.25, 0.25))
	local lateralOffset = lateral * (radius * arcScale)
	state.SearchWaypoint = pivot + forwardOffset + lateralOffset
end

function runSearchPattern(state: NPCState, dt: number)
	local root = state.Root
	if not root then
		return
	end

	state.SearchTimer = math.max(0, state.SearchTimer - dt)
	state.SearchPauseTimer = math.max(0, state.SearchPauseTimer - dt)
	state.SearchWanderTimer = math.max(0, state.SearchWanderTimer - dt)

	local function chooseAimlessStep()
		local radius = state.Config.SearchRadius or 10
		local randomDir = Vector3.new(math.random() * 2 - 1, 0, math.random() * 2 - 1)
		if randomDir.Magnitude < 0.1 then
			randomDir = root.CFrame.LookVector
		else
			randomDir = randomDir.Unit
		end

		local distance = radius * (0.35 + math.random() * 0.65)
		state.SearchWaypoint = root.Position + randomDir * distance
		state.SearchWanderTimer = 0.85 + math.random() * 0.7
		state.SearchPauseTimer = 0.12 + math.random() * 0.18
	end

	if not state.SearchWaypoint or (state.SearchWaypoint - root.Position).Magnitude < 2 or state.SearchWanderTimer <= 0 then
		if state.SearchPauseTimer <= 0 then
			chooseAimlessStep()
		end
	end

	if state.SearchPauseTimer > 0 then
		setMovement(state, Vector3.zero)
		playTrack(state, state.Config.Animations and state.Config.Animations.Aiming, true)
		if state.SearchWaypoint then
			driveFacing(state, state.SearchWaypoint)
		end
		return
	end

	local destination = state.SearchWaypoint or (root.Position + root.CFrame.LookVector)
	local move = destination - root.Position
	setMovement(state, move)
	playTrack(state, state.Config.Animations and state.Config.Animations.Aiming, true)
	driveFacing(state, destination)
end

function beginSearch(state: NPCState)
	local root = state.Root
	if not root then
		return
	end
	state.SearchTimer = state.Config.SearchDuration or 3
	state.SearchPivot = nil
	state.SearchDir = if math.random() > 0.5 then 1 else -1
	state.SearchAngle = 0
	state.SearchWaypoint = nil
	state.SearchPauseTimer = 0.2
	state.SearchWanderTimer = 0
	state.SearchVerifying = false
end

function updatePerception(state: NPCState, dt: number)
	local root = state.Root
	if not root then
		return
	end

	if state.Target and not targetIsAlive(state.Target) then
		state.Target = nil
		state.HadLineOfSight = false
		state.LastSeenPosition = nil
		state.LastSeenVelocity = nil
		state.LastSpottedTarget = nil
	end

	state.SightTimer = math.max(0, state.SightTimer - dt)

	if not state.Target or not state.Target.Parent then
		state.StateTag = "Searching"
		state.HadLineOfSight = false
		if state.LastSeenPosition and not state.SearchVerifying then
			state.SearchVerifying = true
			state.SearchTimer = 0
			state.SearchPauseTimer = 0
			state.SearchWanderTimer = 0
		elseif (not state.LastSeenPosition) and state.SearchTimer <= 0 then
			beginSearch(state)
		end
		return
	end

	local targetRoot = state.Target:FindFirstChild("HumanoidRootPart")
	if not targetRoot then
		state.StateTag = "Searching"
		state.Target = nil
		state.HadLineOfSight = false
		if state.LastSeenPosition and not state.SearchVerifying then
			state.SearchVerifying = true
			state.SearchTimer = 0
			state.SearchPauseTimer = 0
			state.SearchWanderTimer = 0
		elseif (not state.LastSeenPosition) and state.SearchTimer <= 0 then
			beginSearch(state)
		end
		return
	end

	local origin = computeAimOrigin(state)
	if not origin then
		return
	end

	if hasLineOfSight(origin, targetRoot, state.Model) then
		recordSight(state, targetRoot)
		if not state.HadLineOfSight then
			state.ReactionTimer = state.Config.ReactionTime
		end
		state.HadLineOfSight = true
		state.StateTag = "Engaging"
		state.CoverPosition = nil
		state.CoverTimer = 0
	else
		if state.CoverTimer > 0 then
			state.StateTag = "TakingCover"
			state.SightTimer = math.max(state.SightTimer, 0.5)
			return
		end
		if state.SightTimer > 0 then
			state.StateTag = "Chasing"
		else
			state.StateTag = "Searching"
			state.Target = nil
			state.HadLineOfSight = false
			if state.LastSeenPosition and not state.SearchVerifying then
				state.SearchVerifying = true
				state.SearchTimer = 0
				state.SearchPauseTimer = 0
				state.SearchWanderTimer = 0
			elseif (not state.LastSeenPosition) and state.SearchTimer <= 0 then
				beginSearch(state)
			end
		end
	end
end

function updateMovement(state: NPCState, dt: number)
	local humanoid = state.Humanoid
	local root = state.Root
	if not humanoid or not root then
		return
	end

	local prevTag = state.StateTag

	if not state.Target or not state.Target.Parent then
		if state.LastSeenPosition then
			if state.SearchVerifying then
				local toLastSeen = state.LastSeenPosition - root.Position
				if toLastSeen.Magnitude > 2.5 then
					setMovement(state, toLastSeen)
					playTrack(state, state.Config.Animations and state.Config.Animations.Aiming, true)
					driveFacing(state, state.LastSeenPosition)
					return
				else
					state.SearchVerifying = false
					state.LastSeenPosition = nil
					state.LastSeenVelocity = nil
					beginSearch(state)
				end
			elseif state.SearchTimer <= 0 then
				beginSearch(state)
			end
		end

		if state.SearchTimer > 0 then
			runSearchPattern(state, dt)
			return
		end

		if state.LastSeenPosition then
			local toLastSeen = state.LastSeenPosition - root.Position
			setMovement(state, toLastSeen)
			playTrack(state, state.Config.Animations and state.Config.Animations.Aiming, true)
			driveFacing(state, state.LastSeenPosition)
		else
			setMovement(state, Vector3.zero)
			playTrack(state, state.Config.Animations and state.Config.Animations.Idle, true)
		end
		return
	end

	local targetRoot = state.Target:FindFirstChild("HumanoidRootPart")
	if not targetRoot then
		if state.LastSeenPosition then
			if state.SearchVerifying then
				local toLastSeen = state.LastSeenPosition - root.Position
				if toLastSeen.Magnitude > 2.5 then
					setMovement(state, toLastSeen)
					playTrack(state, state.Config.Animations and state.Config.Animations.Aiming, true)
					driveFacing(state, state.LastSeenPosition)
					return
				else
					state.SearchVerifying = false
					state.LastSeenPosition = nil
					state.LastSeenVelocity = nil
					beginSearch(state)
				end
			elseif state.SearchTimer <= 0 then
				beginSearch(state)
			end
		end

		if state.SearchTimer > 0 then
			runSearchPattern(state, dt)
			return
		end

		local toLastSeen = (state.LastSeenPosition or root.Position) - root.Position
		setMovement(state, toLastSeen)
		playTrack(state, state.Config.Animations and state.Config.Animations.Aiming, true)
		driveFacing(state, state.LastSeenPosition or root.Position + root.CFrame.LookVector)
		return
	end

	state.StrafeTimer -= dt
	state.JukeTimer = math.max(0, state.JukeTimer - dt)

	local toTarget = targetRoot.Position - root.Position
	local distance = toTarget.Magnitude
	local desiredDir = if distance > 0.001 then toTarget.Unit else Vector3.zero

	if not state.HadLineOfSight then
		if (not state.CoverPosition or state.CoverTimer <= 0) and state.CoverCooldownTimer <= 0 then
			local coverPos, coverNormal = findCoverPosition(state, targetRoot)
			state.CoverPosition = coverPos
			state.CoverNormal = coverNormal
			state.CoverTimer = 10
			state.CoverCooldownTimer = state.Config.CoverCooldown
		end

		local desiredPos = state.CoverPosition or state.LastSeenPosition or targetRoot.Position
		local toCover = desiredPos - root.Position
		local peekDir = Vector3.zero

		if state.CoverTimer > 0 and state.PeekCooldownTimer <= 0 and state.PeekTimer <= 0 then
			state.PeekTimer = state.Config.PeekDuration * 0.6
			state.PeekCooldownTimer = state.Config.PeekCooldown
		end

		if state.PeekTimer > 0 then
			local faceDir = (targetRoot.Position - root.Position)
			if state.CoverNormal then
				faceDir = faceDir + state.CoverNormal * -0.35
			end
			local lateral = Vector3.new(faceDir.Z, 0, -faceDir.X)
			if lateral.Magnitude > 0.001 then
				peekDir = lateral.Unit * 5
			end
		end

		if toCover.Magnitude > 2 then
			setMovement(state, toCover.Unit + peekDir)
		else
			setMovement(state, peekDir)
		end

		if prevTag ~= "TakingCover" then print("taking cover") end
		state.StateTag = "TakingCover"
		playTrack(state, state.Config.Animations and state.Config.Animations.Aiming, true)
		driveFacing(state, state.LastSeenPosition or targetRoot.Position)
		return
	end

	if state.CoverPosition and state.CoverTimer <= 0 then
		state.CoverPosition = nil
		state.CoverNormal = nil
	end

	local inCover = isInCover(state)

	local needsReloadCover = state.ReloadSeekingCover or state.ReloadTimer > 0 or state.Mag < state.Config.ReloadThreshold
	if needsReloadCover and not inCover and state.CoverCooldownTimer <= 0 then
		local coverPos, coverNormal = findCoverPosition(state, targetRoot)
		state.CoverPosition = coverPos
		state.CoverNormal = coverNormal
		state.CoverTimer = 10
		state.CoverCooldownTimer = state.Config.CoverCooldown
		state.PeekTimer = 0
		state.PeekCooldownTimer = 0.35
	end

	if inCover then
		local toCover = state.CoverPosition - root.Position
		local peekDir = Vector3.zero
		if not needsReloadCover and state.CoverTimer > 0 and state.PeekCooldownTimer <= 0 and state.PeekTimer <= 0 then
			state.PeekTimer = state.Config.PeekDuration
			state.PeekCooldownTimer = state.Config.PeekCooldown
		end

		if state.PeekTimer > 0 and not needsReloadCover then
			local faceDir = (targetRoot.Position - root.Position)
			if state.CoverNormal then
				faceDir = faceDir + state.CoverNormal * -0.35
			end
			local lateral = Vector3.new(faceDir.Z, 0, -faceDir.X)
			local lean = if state.CoverNormal then state.CoverNormal * -0.6 else Vector3.zero
			if lateral.Magnitude > 0.001 then
				peekDir = (lateral.Unit * 5) + lean
			else
				peekDir = lean
			end
		end

		if toCover.Magnitude > 2 then
			setMovement(state, toCover.Unit + peekDir)
		elseif peekDir.Magnitude > 0 then
			setMovement(state, peekDir * 0.35)
		else
			setMovement(state, Vector3.zero)
		end

		if prevTag ~= "TakingCover" then print("taking cover") end
		state.StateTag = "TakingCover"
		if needsReloadCover then
			playTrack(state, state.Config.Animations and state.Config.Animations.Reload, false)
		else
			playTrack(state, state.Config.Animations and state.Config.Animations.Aiming, true)
		end
		driveFacing(state, targetRoot.Position)
		if state.CoverTimer <= 0 then
			state.CoverPosition = nil
			state.CoverNormal = nil
		end
		if needsReloadCover and state.ReloadTimer <= 0 then
			state.ReloadSeekingCover = false
		end
		return
	elseif shouldTakeCover(state, distance) and state.CoverCooldownTimer <= 0 then
		local coverPos, coverNormal = findCoverPosition(state, targetRoot)
		state.CoverPosition = coverPos
		state.CoverNormal = coverNormal
		state.CoverTimer = 10
		state.CoverCooldownTimer = state.Config.CoverCooldown
		state.PeekTimer = 0
		state.PeekCooldownTimer = 0.3
	end

	local forwardPull = 0
	if distance > state.Config.AggroDistance then
		forwardPull = 1
	elseif distance > state.Config.MaintainDistance + 8 then
		forwardPull = 0.55
	elseif distance < state.Config.MaintainDistance - 6 then
		forwardPull = -0.35
	end

	local tacticTag = state.StateTag
	local rolePush = Vector3.zero
	local forwardDir = if distance > 0.001 then toTarget.Unit else Vector3.zero
	local lateralDir = Vector3.new(forwardDir.Z, 0, -forwardDir.X)
	if lateralDir.Magnitude < 1e-4 then
		lateralDir = Vector3.new(0, 0, 1)
	else
		lateralDir = lateralDir.Unit
	end

	if state.Role == "Flanker" then
		forwardPull += 0.15
		state.FlankTimer = math.max(state.FlankTimer, 1.25)
		local flankRadius = math.clamp(distance, state.Config.MinFlankDistance, state.Config.MaxFlankDistance)
		local flankTarget = targetRoot.Position + lateralDir * state.StrafeDir * flankRadius
		rolePush = (flankTarget - root.Position)
		if rolePush.Magnitude > 0.001 then
			rolePush = rolePush.Unit * 1.25
		end
		tacticTag = "Flanking"
	elseif state.Role == "Suppressor" then
		forwardPull = math.min(forwardPull, 0.6)
		rolePush = (forwardDir * 0.25) + (lateralDir * 0.55 * state.StrafeDir)
		tacticTag = "Suppressing"
	else
		rolePush = (forwardDir * math.max(0.4, forwardPull)) + (lateralDir * 0.35 * state.StrafeDir)
		tacticTag = "Assaulting"
	end

	if state.StrafeTimer <= 0 then
		state.StrafeDir = -state.StrafeDir
		state.StrafeTimer = state.Config.StrafeSwitchInterval + math.random() * 0.6
	end

	if state.JukeTimer <= 0 and math.random() < state.Config.JukeChance * dt then
		state.StrafeDir = -state.StrafeDir
		state.StrafeTimer = 0.4 + math.random() * 0.3
		state.JukeTimer = state.Config.JukeCooldown
	end

	local desiredDir2 = forwardDir
	local strafe = lateralDir * state.StrafeDir
	local blend = lerp(desiredDir2 * forwardPull, strafe, 0.65) + rolePush * 0.65
	blend = pickFlank(state, blend)

	if state.FlankTimer > 0 then
		blend = blend + strafe * 0.4
	end

	local slideVelocity = nil
	if state.SlideTimer <= 0 then
		slideVelocity = chooseSlide(state, strafe)
	else
		slideVelocity = strafe * state.Config.SlideSpeed
	end

	local moveDir = blend
	if slideVelocity then
		moveDir = moveDir + slideVelocity
	end

	state.MoveBlend = state.MoveBlend + moveDir * dt
	setMovement(state, moveDir)

	if state.ShootingTrackTimer > 0 then
		playTrack(state, state.Config.Animations and state.Config.Animations.Shooting, true)
	else
		playTrack(state, state.Config.Animations and state.Config.Animations.Aiming, true)
	end

	state.StateTag = tacticTag
	driveFacing(state, targetRoot.Position)
end

function reloadIfNeeded(state: NPCState)
	if state.ReloadTimer > 0 then
		return true
	end

	local mustReload = state.Mag <= 0 or (state.Mag < state.Config.ReloadThreshold and math.random() < 0.35)
	if not mustReload then
		return false
	end

	local inCover = isInCover(state)
	local forcedReload = state.ReloadSeekingCover and state.ReloadCoverWait <= 0
	local noThreat = not targetIsAlive(state.Target)

	local hasEmergencyMag = state.Mag <= 0

	if not inCover and not forcedReload and not noThreat and not hasEmergencyMag then
		state.ReloadSeekingCover = true
		state.ReloadCoverWait = math.max(state.ReloadCoverWait, 1.5)
		return true
	end

	local canReload = inCover or forcedReload or noThreat or hasEmergencyMag
	if not canReload then
		state.ReloadSeekingCover = true
		state.ReloadCoverWait = math.max(state.ReloadCoverWait, 1.5)
		return true
	end

	if mustReload then
		local reloadAnim = state.Config.Animations and state.Config.Animations.Reload
		local duration = state.Config.ReloadDuration
		if state.Animator and reloadAnim then
			stopTrack(state)
			local track = state.Animator:LoadAnimation(reloadAnim)
			track.Priority = Enum.AnimationPriority.Action
			track.Looped = false
			track:Play(0.1, 1, 1)
			state.CurrentTrack = track
			if track.Length and track.Length > 0 then
				duration = math.max(duration, track.Length)
			end
		else
			playTrack(state, reloadAnim, false)
		end

		state.ReloadTimer = duration
		state.Mag = state.Config.ReloadThreshold * 2
		state.ShootingTrackTimer = 0
		state.ReloadSeekingCover = not inCover and not noThreat
		state.ReloadCoverWait = 0
		playVoiceLine(state, "Reload")
		return true
	end
	return false
end

function updateShooting(state: NPCState, dt: number)
	state.FireCooldown = math.max(0, state.FireCooldown - dt)
	state.RepositionCooldown = math.max(0, state.RepositionCooldown - dt)

	if reloadIfNeeded(state) then
		return
	end

	local muzzle = computeAimOrigin(state)
	if not muzzle then
		return
	end

	if not state.Target or not state.Target.Parent then
		return
	end

	local targetRoot = state.Target:FindFirstChild("HumanoidRootPart")
	if not targetRoot or not targetIsAlive(state.Target) then
		return
	end

	if state.ReactionTimer > 0 then
		return
	end

	if state.BurstRemaining <= 0 then
		state.BurstRemaining = math.random(state.Config.MinBurst, state.Config.MaxBurst)
		state.PeekTimer = state.Config.PeekDuration
		state.PeekCooldownTimer = state.Config.PeekCooldown
	end

	if state.FireCooldown > 0 then
		return
	end

	if state.RepositionCooldown > 0 then
		return
	end

	local origin = computeAimOrigin(state)
	if not origin then
		return
	end

	if state.Role == "Suppressor" and state.SuppressCooldownTimer <= 0 then
		state.SuppressTimer = math.max(state.SuppressTimer, 0.6)
	end

	local aimOffset = computeAimOffset(state)
	local predicted = predictTargetPosition(targetRoot, state.LastSeenVelocity, state.Config.BulletSpeed, origin.Position)
	local desired = (predicted + aimOffset - origin.Position).Unit

	local spreadDir = makeSpreadDirection(desired, state.Config.SpreadDegrees, state.AccuracyBloom)
	spawnBullet(muzzle, spreadDir, state.Config.BulletSpeed, state.Config, state)

	state.ShootingTrackTimer = math.max(state.ShootingTrackTimer, 0.35)

	state.FireCooldown = 1 / state.Config.FireRate
	state.BurstRemaining -= 1
	state.Mag -= 1
	state.AccuracyBloom += state.Config.BurstInaccuracyGrowth

	local suppressing = state.Role == "Suppressor" or computeSuppressIntent(state, (targetRoot.Position - origin.Position).Magnitude)
	if suppressing then
		state.FireCooldown *= 0.6
	end

	if state.BurstRemaining <= 0 then
		state.RepositionCooldown = state.Config.RepositionCooldown
		state.StrafeTimer = 0.15
		state.StrafeDir = -state.StrafeDir
	end

	if state.PeekTimer <= 0 and state.PeekCooldownTimer <= 0 then
		state.PeekTimer = state.Config.PeekDuration * 0.5
		state.PeekCooldownTimer = state.Config.PeekCooldown
	end

	playTrack(state, state.Config.Animations and state.Config.Animations.Shooting, true)
end

function ensureConnection()
	if postSimConnection then
		return
	end

	postSimConnection = RunService.PostSimulation:Connect(function(dt)
		refreshEnemyCandidates()
		local engagementGroups = buildEngagementGroups()
		pruneUnusedCommanders(engagementGroups)
		for targetModel, squadsForTarget in pairs(engagementGroups) do
			for squadId, group in pairs(squadsForTarget) do
				assignCoordinatedRoles(group, targetModel, squadId)
			end
		end
		announceLastManStanding()
		for index = #activeNPCs, 1, -1 do
			local state = activeNPCs[index]
			if not isAlive(state) then
				if state.CurrentTrack then
					state.CurrentTrack:Stop()
				end
				removeFromSquad(state)
				table.remove(activeNPCs, index)
			else
				state.FootworkPhase += dt
				state.AimVelocity = lerp(state.AimVelocity, Vector3.zero, clamp01(dt * 3))
				state.AccuracyBloom = math.max(1, state.AccuracyBloom - dt * state.Config.AccuracyRecovery)
				state.MoveBlend = state.MoveBlend:Lerp(Vector3.zero, clamp01(dt * 1.6))
				state.VoiceCooldown = math.max(0, state.VoiceCooldown - dt)
				state.SpotCooldownTimer = math.max(0, state.SpotCooldownTimer - dt)
				state.RoleTimer = math.max(0, state.RoleTimer - dt)

				state.ReactionTimer = math.max(0, state.ReactionTimer - dt)
				state.PeekTimer = math.max(0, state.PeekTimer - dt)
				state.PeekCooldownTimer = math.max(0, state.PeekCooldownTimer - dt)
				state.SlideTimer = math.max(0, state.SlideTimer - dt)
				state.SlideCooldownTimer = math.max(0, state.SlideCooldownTimer - dt)
				state.FlankTimer = math.max(0, state.FlankTimer - dt)
				state.FlankCooldownTimer = math.max(0, state.FlankCooldownTimer - dt)
				state.SuppressTimer = math.max(0, state.SuppressTimer - dt)
				state.SuppressCooldownTimer = math.max(0, state.SuppressCooldownTimer - dt)
				state.ReloadTimer = math.max(0, state.ReloadTimer - dt)
				state.ReloadCoverWait = math.max(0, state.ReloadCoverWait - dt)
				state.CoverTimer = math.max(0, state.CoverTimer - dt)
				state.CoverCooldownTimer = math.max(0, state.CoverCooldownTimer - dt)
				state.ShootingTrackTimer = math.max(0, state.ShootingTrackTimer - dt)
				if state.ReloadTimer <= 0 and state.ReloadSeekingCover and state.Mag >= state.Config.ReloadThreshold then
					state.ReloadSeekingCover = false
					state.ReloadCoverWait = 0
				end

				if (state.Mag <= 0 or state.ReloadSeekingCover) and state.ReloadTimer <= 0 then
					reloadIfNeeded(state)
				end

				if not state.Humanoid or not state.Root then
					if state.Humanoid then
						state.Humanoid:Move(Vector3.zero, false)
					end
					continue
				end

				if state.ReloadTimer > 0 then
					playTrack(state, state.Config.Animations and state.Config.Animations.Reload, false)

					local moveTowardCover = Vector3.zero
					if state.CoverPosition and state.CoverTimer > 0 and state.Root then
						local toCover = state.CoverPosition - state.Root.Position
						if toCover.Magnitude > 2 then
							moveTowardCover = toCover
						end
					end

					setMovement(state, moveTowardCover)
					if state.Target and state.Root then
						local targetRoot = state.Target:FindFirstChild("HumanoidRootPart")
						if targetRoot then
							driveFacing(state, targetRoot.Position)
						end
					end

					state.ReloadSeekingCover = moveTowardCover.Magnitude > 0 and state.CoverTimer <= 0
					continue
				end

				pickTarget(state)
				updatePerception(state, dt)
				updateMovement(state, dt)
				updateShooting(state, dt)
			end
		end

		if #activeNPCs == 0 then
			postSimConnection:Disconnect()
			postSimConnection = nil
		end
	end)
end

function m.start(model: Model, configOverride: any?)
	assert(model, "Model is required")
	local humanoid = model:FindFirstChildWhichIsA("Humanoid")
	local animator = humanoid and humanoid:FindFirstChildWhichIsA("Animator")
	if humanoid and not animator then
		animator = Instance.new("Animator")
		animator.Parent = humanoid
	end
	local root = model:FindFirstChild("HumanoidRootPart")
	local config = loadModelConfig(model, configOverride)
	local state: NPCState = {
		Model = model,
		Root = root,
		Humanoid = humanoid,
		Animator = animator,
		Gun = nil,
		Gunshot = nil,
		Target = nil,
		Config = blendConfigs(config),
		FireCooldown = 0,
		BurstRemaining = 0,
		RepositionCooldown = 0,
		StrafeTimer = 0,
		StrafeDir = if math.random() > 0.5 then 1 else -1,
		JukeTimer = 0,
		CurrentTrack = nil,
		AimVelocity = Vector3.zero,
		SightTimer = 0,
		HadLineOfSight = false,
		LastSeenPosition = nil,
		LastSeenVelocity = nil,
		ReactionTimer = 0,
		PeekTimer = 0,
		PeekCooldownTimer = 0,
		SlideTimer = 0,
		SlideCooldownTimer = 0,
		SlideDir = nil,
		FlankTimer = 0,
		FlankCooldownTimer = 0,
		SuppressTimer = 0,
		SuppressCooldownTimer = 0,
		ReloadTimer = 0,
		Mag = 30,
		AccuracyBloom = 1.2,
		CoverTimer = 0,
		CoverCooldownTimer = 0,
		CoverPosition = nil,
		CoverNormal = nil,
		SearchTimer = 0,
		SearchPivot = nil,
		SearchDir = 1,
		SearchAngle = 0,
		SearchWaypoint = nil,
		SearchPauseTimer = 0,
		SearchWanderTimer = 0,
		SearchVerifying = false,
		StateTag = "Searching",
		FootworkPhase = math.random() * math.pi,
		MoveBlend = Vector3.zero,
		ShootingTrackTimer = 0,
		ActiveOrderFrom = nil,
		VoiceCooldown = 0,
		SpotCooldownTimer = 0,
		LastSpottedTarget = nil,
		ReloadSeekingCover = false,
		ReloadCoverWait = 0,
		Role = "Assault",
		RoleTimer = 0,
		SquadId = nil,
	}
	bindDeath(state)

	tagCharacter(model)
	refreshAttachments(state)
	assignToSquad(state)
	table.insert(activeNPCs, state)
	ensureConnection()
	return state
end

function m.AddNPC(model: Model, config: any?)
	return m.start(model, config)
end

function m.SetTarget(model: Model, target: Model?)
	for _, state in ipairs(activeNPCs) do
		if state.Model == model then
			if target and isNPCModel(target) then
				return
			end
			state.Target = targetIsAlive(target) and target or nil
			return
		end
	end
end

function m.RemoveNPC(model: Model)
	for index = #activeNPCs, 1, -1 do
		local state = activeNPCs[index]
		if state.Model == model then
			if state.CurrentTrack then
				state.CurrentTrack:Stop()
			end
			removeFromSquad(state)
			table.remove(activeNPCs, index)
			break
		end
	end

	if #activeNPCs == 0 and postSimConnection then
		postSimConnection:Disconnect()
		postSimConnection = nil
	end
end

function m.RefreshGun(model: Model)
	for _, state in ipairs(activeNPCs) do
		if state.Model == model then
			refreshAttachments(state)
			return
		end
	end
end

function addStartupNPC(entry: any)
	if typeof(entry) == "Instance" then
		m.AddNPC(entry, nil)
	elseif typeof(entry) == "table" then
		if entry.Model then
			m.AddNPC(entry.Model, entry.Config)
		else
			for _, nested in ipairs(entry) do
				addStartupNPC(nested)
			end
		end
	end
end

function m.idk(models: any)
	assert(models, "Start requires at least one NPC Model")
	addStartupNPC(models)
	started = true
	return activeNPCs
end

function m.ListNPCs(): { NPCState }
	return activeNPCs
end

function m.Reset()
	for index = #activeNPCs, 1, -1 do
		m.RemoveNPC(activeNPCs[index].Model)
	end
	commanderByTarget = {}
	squads = {}
	nextSquadId = 1
	started = false
end

return m
