local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SimplePath = require(ReplicatedStorage["SimplePath (modified)"])
local Ragdoll = require(ReplicatedStorage.RagdollModule)
--local Dialogue = require(ReplicatedStorage.Dialogue)
local RunService = game:GetService("RunService")
local BadgeService = game:GetService("BadgeService")
local phase2 = "rbxassetid://82662790428918"
local Socket = require(game.ReplicatedStorage.Modules.Socket)
local lastmanstanding = false
local targetKilled = false
local DialogueModule = require(game.ReplicatedStorage:WaitForChild("Dialogue"))
--[[DialogueModule.ShowDialogueV2({
	InitialLayer = "Layer1",
	SkinName = "DefaultDark",
	Config = nil,

	Layers = {
		Layer1 = {
			Dialogue = {
				"THIS TIME... ILL MAKE SURE YOU STAY OUT OF OUR BUSINESS."
			},

			DialogueSounds = {nil, nil},
			DialogueImage = "rbxassetid://121066929966916",
			Title = "Auditor",

			Replies = { 
			},

			Exec = {
			}
		},

		Layer2 = {
			Dialogue = {"Thanks for replying."},
			DialogueSounds = {},
			DialogueImage = "rbxassetid://105363732563445",
			Title = "MichaelVargas",

			Replies = {
			},

			Exec = {
			}
		}
	}

})]]
local Players = game:GetService("Players")
local Dummy = script.Parent
local dhrp = Dummy.HumanoidRootPart
local Torso = Dummy.Torso
local Path = SimplePath.new(Dummy)
local bodyGyro = Instance.new("BodyGyro")
bodyGyro.MaxTorque = Vector3.new(1e6, 1e6, 1e6)
bodyGyro.P = 1e4
bodyGyro.CFrame = Dummy.PrimaryPart.CFrame
bodyGyro.Parent = Dummy.PrimaryPart

local Slash = Dummy.Slash
local Infect = Dummy.Infection
local Parry = Dummy.Parry
local RTR = Dummy.RTR
local Shockwave = ReplicatedStorage.Audwave
local Swords = ReplicatedStorage.Audswords
local Zombie = game.ServerStorage.NPCS.AudZombie
local sky = game.Lighting:FindFirstChild("SFOTH")


local Lighting = game:GetService("Lighting")
Lighting.ClockTime = 14
Lighting.Brightness = 2
Lighting.Ambient = Color3.fromRGB(150, 150, 150)
Lighting.OutdoorAmbient = Color3.fromRGB(180, 180, 180)
Lighting.FogEnd = 100000 
Lighting.FogColor = Color3.fromRGB(255, 255, 255)
local function findSpawnLocationInModels()
	for _, obj in ipairs(game.Workspace:GetDescendants()) do
		if obj:IsA("Model") then
			local spawnLocation = obj:FindFirstChild("SpawnLocation")
			if spawnLocation then
				return spawnLocation
			else
				return Vector3.new(0,0,0)
			end
		end
	end
	return nil
end
local goal = findSpawnLocationInModels()
Path.Visualize = false
task.wait(8)

local function GetNearestCharacter(fromPosition)
	local character, dist = nil, math.huge
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Character and player.Character.PrimaryPart then
			local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
			if humanoid and humanoid.Health > 0 then
				local npcAttr = player.Character:GetAttribute("NPC")
				if not npcAttr then
				local distance = (player.Character.PrimaryPart.Position - fromPosition).Magnitude
				if distance < dist then
					character, dist = player.Character, distance
					end
				end
			end
		end
	end
	return character
end
local npcConnections = {}
local MAX_NPCS = 10
local connectorCounter = 0
local npcLinks = {}

local function tableCount(t)
	local count = 0
	for _ in pairs(t) do
		count += 1
	end
	return count
end
local function getConnectionCount()
	local count = 0
	for _ in pairs(npcConnections) do
		count += 1
	end
	return count
end
local humanoid = Dummy:FindFirstChildOfClass("Humanoid")
local raged = false
local ragedplayed = false
local function registerNPC(npc)
	if not npc or not npc.Parent then return end
	local hum = npc:FindFirstChildOfClass("Humanoid"); if not hum then return end
	local hrp = npc:FindFirstChild("HumanoidRootPart"); if not hrp then return end
	local connectorTemplate = Dummy.HumanoidRootPart:FindFirstChild("Connector"); if not connectorTemplate then return end
	local Resistance = Dummy:FindFirstChild("Resistance")

	connectorCounter += 1
	local connector = connectorTemplate:Clone()
	connector.Name = "Connector.."..connectorCounter
	connector.Parent = Dummy.HumanoidRootPart

	local targetAttachment = Instance.new("Attachment")
	targetAttachment.Name = "ConnectorTarget_"..connectorCounter
	targetAttachment.Parent = hrp

	local beam = connector:FindFirstChildWhichIsA("Beam", true) or connector:FindFirstChild("Beam")
	if beam and ragedplayed then
		beam.Attachment1 = targetAttachment
	end

	npcLinks = npcLinks or {}
	npcLinks[npc] = {connector = connector, attachment = targetAttachment}

	

	local conn
	conn = hum.HealthChanged:Connect(function(health)
		if health <= 0 then
			if ragedplayed and Resistance then
				Resistance.Value = math.max(0, Resistance.Value - 10)
			end

			for npcRef, connection in pairs(npcConnections) do
				if not npcRef or not npcRef.Parent then
					connection:Disconnect()
					npcConnections[npcRef] = nil
				end
			end

			if npcConnections[npc] then
				npcConnections[npc]:Disconnect()
				npcConnections[npc] = nil
			end
			if npcLinks[npc] then
				if npcLinks[npc].connector then npcLinks[npc].connector:Destroy() end
				if npcLinks[npc].attachment then npcLinks[npc].attachment:Destroy() end
				npcLinks[npc] = nil
			end
			print("Connections left:", tableCount(npcConnections))
		end
	end)

	npcConnections[npc] = conn
	if ragedplayed and Resistance then
		local total = 0
		for npcRef in pairs(npcConnections) do
			if npcRef and npcRef.Parent then
				total += 1
			end
		end
		Resistance.Value = total * 10
	end
	print("registered")
	print("Total connections:", tableCount(npcConnections))
end

--[[task.spawn(function()
	while task.wait(90) do
		if ragedplayed then
		local aliveCount = 0
		for npc, conn in pairs(npcConnections) do
			if npc and npc.Parent then
				local hum = npc:FindFirstChildOfClass("Humanoid")
				if hum and hum.Health > 0 then
					aliveCount += 1
				end
			end
		end
		if humanoid and humanoid.Health > 0 then
			humanoid.Health = math.min(humanoid.Health + (aliveCount * 100), humanoid.MaxHealth)
			end
		end
	end
end)]]
local function cleanupNPCs()
	for npc, conn in pairs(npcConnections) do
		if conn then conn:Disconnect() end
	end
	table.clear(npcConnections)
end
local function OnDeath()
	Path:Stop()

	if Dummy.Name == "Decoy" then
		Dummy:Destroy()
		return
	end

	task.wait(1)
	Dummy:Destroy()
end


local attacking = false
local Kicking = false
local casting = false
local throwing = false
local Stunned = false
local attackDamage = 58   
local shockwavedmg = 35
local entangledmg = 30
local spawning = false
local spawnCooldown = 10
local lastSpawn = 0
local attackAnimation = Instance.new("Animation")
attackAnimation.AnimationId = "rbxassetid://100038519437341" 
local kickAnimation = Instance.new("Animation")
kickAnimation.AnimationId = "rbxassetid://102168159363765" 
local castAnimation = Instance.new("Animation")
castAnimation.AnimationId = "rbxassetid://140707619122346" 
local throwanimation = Instance.new("Animation")
throwanimation.AnimationId = "rbxassetid://71849427538261" 
local RageAnimation = Instance.new("Animation")
RageAnimation.AnimationId = "rbxassetid://121118630044529"
local RageAnimation2 = Instance.new("Animation")
RageAnimation2.AnimationId = "rbxassetid://124199568566128"
local castTrack = humanoid:LoadAnimation(castAnimation)

local connection
--[[connection = RunService.Heartbeat:Connect(function()
	if not humanoid or humanoid.Health <= 0 then
		connection:Disconnect()
		return
	end

	local npcPos = Dummy.PrimaryPart.Position
	local nearestCharacter = GetNearestCharacter(npcPos)

	if not attacking then
		if nearestCharacter and nearestCharacter.PrimaryPart then
			local targetPos = nearestCharacter.PrimaryPart.Position
			local dist = (npcPos - targetPos).Magnitude

			if dist < 30 and math.random() < 0.01 then
				attacking = true
				local target = nearestCharacter
				task.spawn(function()
					while humanoid.Health > 0 and target.PrimaryPart and (Dummy.PrimaryPart.Position - target.PrimaryPart.Position).Magnitude > 7 do
						Path:Run(target.PrimaryPart.Position)
						task.wait(0.1)
					end

					if humanoid.Health > 0 and target.PrimaryPart then
						local track = humanoid:LoadAnimation(attackAnimation)
						track:Play()
						Slash:Play()
						task.wait(0.5)
						if target.PrimaryPart and (Dummy.PrimaryPart.Position - target.PrimaryPart.Position).Magnitude <= 7 then
							local th = target:FindFirstChildOfClass("Humanoid")
							if th then th:TakeDamage(attackDamage) end
						end
						track:Stop()
					end

					attacking = false
				end)
			else
				local direction = (targetPos - npcPos).Unit
				local desiredPos = targetPos - direction * 20
				Path:Run(desiredPos)
			end
		else
			Path:Run(goal)
		end
	end

	if nearestCharacter and nearestCharacter.PrimaryPart then
		bodyGyro.CFrame = CFrame.new(Dummy.PrimaryPart.Position, nearestCharacter.PrimaryPart.Position)
	end
end)]]
local touchedPlayers2 = {}
local damaged = {} 

connection = RunService.Heartbeat:Connect(function()

	if not humanoid or humanoid.Health <= 0 then
		connection:Disconnect()
		return
	end
	local function isInHaxxedSwordModel(instance)
		local parent = instance.Parent
		while parent do
			if parent:IsA("Model") and parent.Name:lower():find("haxxedsword") then
				return true
			end
			parent = parent.Parent
		end
		return false
	end
	local function summonBeamCircle(position: Vector3, radius: number, expansiontime: number)
		local rcParams = RaycastParams.new()
		rcParams.FilterType = Enum.RaycastFilterType.Exclude
		rcParams.FilterDescendantsInstances = { Dummy }

		local result = workspace:Raycast(position + Vector3.new(0, 60, 0), Vector3.new(0, -120, 0), rcParams)
		if not result or result.Normal.Y <= 0.7 then return end
		local pos = result.Position

		local segmentCount = 32
		local circleFolder = Instance.new("Folder")
		circleFolder.Name = "WarningCircleSegments"
		circleFolder.Parent = workspace

		local initialRadius = 1
		local maxRadius = radius
		local expandTime = expansiontime
		local steps = 30
		local radiusStep = (maxRadius - initialRadius) / steps
		local waitTime = expandTime / steps

		for step = 1, steps do
			local currentRadius = initialRadius + radiusStep * (step - 1)
			circleFolder:ClearAllChildren()
			for i = 1, segmentCount do
				local angle = (2 * math.pi / segmentCount) * i
				local offset = Vector3.new(math.cos(angle) * currentRadius, 0, math.sin(angle) * currentRadius)
				local part = Instance.new("Part")
				part.Size = Vector3.new(1, 0.2, 1)
				part.Anchored = true
				part.CanCollide = false
				part.CanQuery = false
				part.Material = Enum.Material.Neon
				part.Color = Color3.fromRGB(0, 0, 0)
				part.CFrame = CFrame.new(pos + offset + Vector3.new(0, 0.1, 0))
				part.Parent = circleFolder
			end
			task.wait(waitTime)
		end

		circleFolder:Destroy()

		local beam = game.ReplicatedStorage.Templates:WaitForChild("AudBeam"):Clone()
		beam.Name = "RedBeam"
		beam.Anchored = true
		beam.CanCollide = false
		beam.CanQuery = false
		beam.Transparency = 0.15

		local beamHeight = 120
		local growTime = 0.4
		local fps = 60
		local initialHeight = 0.1

		beam.Size = Vector3.new(radius * 2, initialHeight, radius * 2)
		beam.CFrame = CFrame.new(pos + Vector3.new(0, initialHeight / 2, 0))
		beam.Parent = workspace

		local growSteps = math.floor(fps * growTime)
		for i = 1, growSteps do
			local alpha = i / growSteps
			local currentHeight = initialHeight + (beamHeight - initialHeight) * alpha
			beam.Size = Vector3.new(radius * 2, currentHeight, radius * 2)
			beam.CFrame = CFrame.new(pos + Vector3.new(0, currentHeight / 2, 0))
			RunService.Heartbeat:Wait()
		end

		local damaged = {}

		beam.Touched:Connect(function(hit)
			local character = hit.Parent
			if not character then return end

			local hum = character:FindFirstChildOfClass("Humanoid")
			local HRP = character:FindFirstChild("HumanoidRootPart")
			if not hum or not HRP then return end
			if character == Dummy then return end

			if damaged[hum] then return end
			damaged[hum] = true

			local knockback = {}
			knockback.Direction = (-HRP.CFrame.LookVector + Vector3.new(0, 1, 0)).Unit
			knockback.Strength = 100

			if character.Name == "AudZombie" then
				hum:TakeDamage(0)
			else
				hum:TakeDamage(30)
				Ragdoll:Ragdoll(character, knockback, 3)
			end

			task.delay(0.5, function()
				damaged[hum] = nil
			end)
		end)

		game:GetService("Debris"):AddItem(beam, 0.6)
	end
	local npcPos = Dummy.PrimaryPart.Position
	local nearestCharacter = GetNearestCharacter(npcPos)
	local rageEffectBackup = {}
	local function CastShockwave()
		Path:Stop()
		casting = true
		local target = nearestCharacter

		task.spawn(function()
			print("spawned2")
			local castTrack = humanoid:LoadAnimation(castAnimation)
			castTrack:Play()
			Infect:Play()

			local hrp = Dummy:FindFirstChild("HumanoidRootPart")


			task.wait(1.3)

			task.wait(0.4)


			if Dummy and Dummy.PrimaryPart then
				local function interceptDir(shooterPos, projectileSpeed, targetPos, targetVel)
					shooterPos = Vector3.new(shooterPos.X, 0, shooterPos.Z)
					targetPos = Vector3.new(targetPos.X, 0, targetPos.Z)
					targetVel = Vector3.new(targetVel.X, 0, targetVel.Z)
					local r = targetPos - shooterPos
					local v = targetVel
					local vv = v:Dot(v)
					local s2 = projectileSpeed * projectileSpeed
					local a = vv - s2
					local b = 2 * r:Dot(v)
					local c = r:Dot(r)
					local t
					if math.abs(a) < 1e-3 then
						if math.abs(b) < 1e-3 then
							t = 0
						else
							t = math.max(-c / b, 0)
						end
					else
						local disc = b * b - 4 * a * c
						if disc < 0 then
							t = 0
						else
							local sqrtDisc = math.sqrt(disc)
							local t1 = (-b - sqrtDisc) / (2 * a)
							local t2 = (-b + sqrtDisc) / (2 * a)
							if t1 > 0 and t2 > 0 then
								t = math.min(t1, t2)
							elseif t1 > 0 then
								t = t1
							elseif t2 > 0 then
								t = t2
							else
								t = 0
							end
						end
					end
					local aimPos = targetPos + v * t
					local dir = aimPos - shooterPos
					if dir.Magnitude < 1e-3 then
						return r.Unit
					end
					return dir.Unit
				end

				local function rotateY(v, ang)
					local c = math.cos(ang)
					local s = math.sin(ang)
					return Vector3.new(v.X * c - v.Z * s, 0, v.X * s + v.Z * c).Unit
				end

				local function fireShockwave(dir, curveOffset, delay, speed, duration, steps)
					task.spawn(function()
						if delay and delay > 0 then task.wait(delay) end

						local shockwave = Shockwave:Clone()
						shockwave.Parent = workspace
						if not shockwave.PrimaryPart then shockwave:Destroy() return end

						shockwave.PrimaryPart.Anchored = true
						shockwave:SetPrimaryPartCFrame(Dummy.PrimaryPart.CFrame)

						local collider = Instance.new("Part")
						collider.Size = shockwave.PrimaryPart.Size
						collider.Transparency = 1
						collider.Anchored = false
						collider.CanCollide = false
						collider.CanTouch = true
						collider.Position = shockwave.PrimaryPart.Position
						collider.Parent = workspace

						local weld = Instance.new("Weld")
						weld.Part0 = collider
						weld.Part1 = shockwave.PrimaryPart
						weld.Parent = collider

						local touchedPlayers = {}
						collider.Touched:Connect(function(hit)
							local character = hit:FindFirstAncestorWhichIsA("Model")
							if character and character ~= Dummy and not touchedPlayers[character] then
								local hum = character:FindFirstChildOfClass("Humanoid")
								if hum then
									touchedPlayers[character] = true
									hum:TakeDamage(shockwavedmg)
								end
							end
						end)

						local damageCube = Instance.new("Part")
						damageCube.Size = Vector3.new(10, 10, 10)
						damageCube.CFrame = Dummy.PrimaryPart.CFrame
						damageCube.Transparency = 1
						damageCube.Anchored = false
						damageCube.CanCollide = false
						damageCube.CanTouch = true
						damageCube.Name = "DamageCube"
						damageCube.Parent = workspace

						local weldCube = Instance.new("Weld")
						weldCube.Part0 = damageCube
						weldCube.Part1 = Dummy.PrimaryPart
						weldCube.C0 = CFrame.new()
						weldCube.C1 = CFrame.new()
						weldCube.Parent = damageCube

						local alreadyDamaged = {}
						damageCube.Touched:Connect(function(hit)
							local character = hit:FindFirstAncestorWhichIsA("Model")
							if character and character ~= Dummy and not alreadyDamaged[character] then
								local hum = character:FindFirstChildOfClass("Humanoid")
								if hum then
									alreadyDamaged[character] = true
									hum:TakeDamage(70)
								end
							end
						end)

						task.delay(0.2, function()
							if damageCube then
								damageCube:Destroy()
							end
						end)

						local RunService = game:GetService("RunService")
						local startCf = shockwave:GetPivot()
						local totalTime = duration
						local startPos = startCf.Position
						local endPos = startPos + dir * (speed * totalTime)
						local controlPos = (curveOffset and (startPos + dir * (speed * totalTime * 0.5) + curveOffset)) or nil
						local lastPos = startPos
						local elapsed = 0
						local conn
						conn = RunService.Heartbeat:Connect(function(dt)
							elapsed += dt
							local a = math.clamp(elapsed / totalTime, 0, 1)
							local pos
							if controlPos then
								local u = 1 - a
								pos = u*u*startPos + 2*u*a*controlPos + a*a*endPos
							else
								pos = startPos:Lerp(endPos, a)
							end
							local nextA = math.clamp(a + 0.02, 0, 1)
							local nextPos
							if controlPos then
								local u2 = 1 - nextA
								nextPos = u2*u2*startPos + 2*u2*nextA*controlPos + nextA*nextA*endPos
							else
								nextPos = startPos:Lerp(endPos, nextA)
							end
							local forward = (nextPos - pos)
							if forward.Magnitude < 1e-4 then forward = dir end
							local look = CFrame.new(pos, pos + forward.Unit)
							shockwave:PivotTo(look)
							local vel = (pos - lastPos) / math.max(dt, 1/240)
							collider.AssemblyLinearVelocity = Vector3.new(vel.X, 0, vel.Z)
							lastPos = pos
							if a >= 1 then
								collider.AssemblyLinearVelocity = Vector3.zero
								if conn then conn:Disconnect() end
							end
						end)
						game:GetService("Debris"):AddItem(shockwave, 3)
					end)
				end

				local speed = 80
				local duration = 1.5
				local steps = 30
				local targetRoot = target and target.PrimaryPart
				local baseDir
				if targetRoot then
					baseDir = interceptDir(Dummy.PrimaryPart.Position, speed, targetRoot.Position, targetRoot.AssemblyLinearVelocity)
				else
					baseDir = Dummy.PrimaryPart.CFrame.LookVector.Unit
				end
				local right = Vector3.new(-baseDir.Z, 0, baseDir.X).Unit
				local pattern = math.random(1,5)
				if pattern == 1 then
					fireShockwave(baseDir, nil, 0, speed, duration, steps)
				elseif pattern == 2 then
					local v = targetRoot and targetRoot.AssemblyLinearVelocity or Vector3.zero
					local lateral = Vector3.new(v.X, 0, v.Z):Dot(right)
					local side = (lateral >= 0) and 1 or -1
					local dirA = rotateY(baseDir, math.rad(18) * side)
					fireShockwave(dirA, nil, 0, speed, duration, steps)
				elseif pattern == 3 then
					local v = targetRoot and targetRoot.AssemblyLinearVelocity or Vector3.zero
					local v2 = Vector3.new(v.X, 0, v.Z)
					local aimBehind = targetRoot and (Vector3.new(targetRoot.Position.X, 0, targetRoot.Position.Z) - (v2.Magnitude > 0 and v2.Unit * 8 or Vector3.zero)) or Vector3.zero
					local shooterXZ = Vector3.new(Dummy.PrimaryPart.Position.X, 0, Dummy.PrimaryPart.Position.Z)
					local dirB
					if targetRoot then
						local d = aimBehind - shooterXZ
						dirB = (d.Magnitude > 1e-3) and d.Unit or baseDir
					else
						dirB = baseDir
					end
					fireShockwave(dirB, nil, 0, speed, duration, steps)
				else
					local side = (math.random() < 0.5) and -1 or 1
					local curve = right * side * 12
					fireShockwave(baseDir, curve, 0, speed, duration, steps)
				end
			end



			casting = false
		end)
	end

	if not raged and not ragedplayed and humanoid.Health <= (humanoid.MaxHealth / 2) then
		repeat
			task.wait()
		until not attacking and not casting and not throwing
		Path:Stop()
		raged = true
		ragedplayed = true
		game.SoundService.Music.SoundId = phase2
		game.SoundService.Music.TimePosition = 0
		game.SoundService.Music.Volume = 1


		for _, descendant in ipairs(Dummy.ExtraModels:GetDescendants()) do
			if isInHaxxedSwordModel(descendant) then
				if descendant:IsA("BasePart") and descendant.Transparency < 1 then
					table.insert(rageEffectBackup, {part = descendant, transparency = descendant.Transparency})
					descendant.Transparency = 1
				elseif descendant:IsA("ParticleEmitter") or descendant:IsA("Beam") then
					if descendant.Enabled == true then
						table.insert(rageEffectBackup, {effect = descendant})
						descendant.Enabled = false
					end
				end
			end
		end

		local rageTrack = humanoid:LoadAnimation(RageAnimation)
		rageTrack:Play()
		task.wait(0.5)
		RTR:Play()


		local Effects = Dummy.Head:FindFirstChild("EyesFlare")

		--[[local map = game.ReplicatedStorage.Crossroad
		workspace["Sword Fight on the Heights IV Map"]:Destroy()
		map.Parent = workspace]]



		rageTrack.Stopped:Connect(function()
			DialogueModule.ShowDialogueV2({
				InitialLayer = "Layer1",
				SkinName = "DefaultDark",
				Config = nil,

				Layers = {
					Layer1 = {
						Dialogue = {
							"WHO DO YOU THINK YOU ARE?",
							"STAND DOWN MORTALS"
						},

						DialogueSounds = {nil, nil},
						DialogueImage = "rbxassetid://121066929966916",
						Title = "Auditor",

						Replies = { 
						},

						Exec = {
						}
					},

					Layer2 = {
						Dialogue = {"Thanks for replying."},
						DialogueSounds = {},
						DialogueImage = "rbxassetid://105363732563445",
						Title = "MichaelVargas",

						Replies = {
						},

						Exec = {
						}
					}
				}

			})
			local hrp = Dummy:FindFirstChild("HumanoidRootPart")
			raged = false
			Dummy.Head.AudiHalo.Transparency = 0


			for _, data in ipairs(rageEffectBackup) do
				if data.part then
					data.part.Transparency = data.transparency
				elseif data.effect then
					data.effect.Enabled = true
				end
			end
			entangledmg = 20
			attackDamage = 40
			shockwavedmg = 45

			rageEffectBackup = {}
		end)
	end




	if not attacking and not (casting or throwing or spawning or Stunned)  then
		if nearestCharacter and nearestCharacter.PrimaryPart then
			local targetPos = nearestCharacter.PrimaryPart.Position
			local dist = (npcPos - targetPos).Magnitude

			-- ATTACKING LOGIC
			if dist < 40 and math.random() < 0.01 and not (raged or targetKilled or Stunned) then
				attacking = true
				local target = nearestCharacter
				task.spawn(function()
					if not target or not target.PrimaryPart then attacking = false return end

					local function distToTarget()
						if not target or not target.PrimaryPart or not Dummy or not Dummy.PrimaryPart then
							return math.huge
						end
						return (Dummy.PrimaryPart.Position - target.PrimaryPart.Position).Magnitude
					end

					local params = RaycastParams.new()
					params.FilterType = Enum.RaycastFilterType.Exclude
					params.FilterDescendantsInstances = { Dummy }
					local function hasLOS(fromPos, toPos)
						local dir = toPos - fromPos
						local result = workspace:Raycast(fromPos + Vector3.new(0, 3, 0), dir, params)
						return (not result) or result.Instance:IsDescendantOf(target)
					end

					local startT = time()
					local attemptEnds = startT + 6
					local commitEarliest = startT + 1.1
					local hardCommit = startT + 5.25
					local committed = false
					local side = (math.random() < 0.5) and -1 or 1
					local strategy = math.random(1,6)
					local nextStrategy = startT + 0.9 + math.random() * 0.5
					local feintTimer = startT + 0.45
					local feintMode = 0
					local baitBack = false

					while humanoid.Health > 0 and target and target.PrimaryPart and time() < attemptEnds do
						if Stunned then break end
						local npcPos = Dummy.PrimaryPart.Position
						local tgtPos = target.PrimaryPart.Position
						local flatDir = (Vector3.new(tgtPos.X, npcPos.Y, tgtPos.Z) - npcPos)
						if flatDir.Magnitude < 1e-3 then break end
						local forward = flatDir.Unit
						local right = Vector3.new(-forward.Z, 0, forward.X)
						local t = time()

						if t >= nextStrategy then
							strategy = math.random(1,6)
							side = (math.random() < 0.5) and -side or side
							nextStrategy = t + 0.9 + math.random() * 0.6
						end
						if t >= feintTimer then
							feintMode = ({-1,0,1})[math.random(1,3)]
							feintTimer = t + 0.35 + math.random() * 0.35
						end

						local phase = math.clamp((t - startT) / (commitEarliest - startT), 0, 1)
						local keepDist = (12 + 4 * math.noise(t * 0.7)) * (1 - phase) + 6 * phase
						local strafeAmp = 8 * (1 - phase) + 3 * phase
						local jitter = Vector3.new(math.noise(t * 3.1, 1) * 1.2, 0, math.noise(t * 3.1, 2) * 1.2)
						local desired = tgtPos

						local n1 = math.noise(t * 0.9)
						local n2 = math.noise(t * 1.6)
						local burst = (n2 > 0.35) and 6 or 0

						if strategy == 1 then
							local angleBias = side * (1.0 + 0.7 * math.abs(n1))
							local flank = right * angleBias * (keepDist * 1.05)
							local orbit = tgtPos - forward * (keepDist * 0.55)
							local strafe = right * (math.noise(t * 1.6) * (strafeAmp * 1.8))
							desired = orbit + flank + strafe + (forward * burst) + jitter

						elseif strategy == 2 then
							local theta = (side < 0 and -1 or 1) * math.rad(95)
							local dir = (forward * math.cos(theta) + right * math.sin(theta)).Unit
							desired = tgtPos - dir * (keepDist * 0.75) + right * side * 6 + forward * 4 + jitter

						elseif strategy == 3 then
							local s = math.sign(math.sin(t * 9.5))
							local zig = right * s * (10 + 6 * math.noise(t * 2.7))
							desired = tgtPos - forward * (keepDist - 6) + zig + forward * (3 * math.noise(t * 0.8)) + jitter

						elseif strategy == 4 then
							if not baitBack and distToTarget() < 12 then baitBack = true end
							if baitBack then
								desired = npcPos - forward * 10 + right * side * 7 + jitter
							else
								desired = tgtPos - forward * (keepDist * 0.8) + right * side * 7 + jitter
							end

						elseif strategy == 5 then
							local v = target.PrimaryPart.AssemblyLinearVelocity
							local v2 = Vector3.new(v.X, 0, v.Z)
							local lead = v2 * 0.45
							local lateral = v2:Dot(right)
							desired = tgtPos + lead + right * (math.sign(lateral) * 5)
							- forward * (keepDist - 1) + right * side * 6 + jitter

						else
							desired = tgtPos - forward * (keepDist * 0.6) + right * side * 7 + forward * 4 + jitter
						end

						if feintMode == 1 then
							desired = desired - forward * 9 + right * side * 6
						elseif feintMode == -1 then
							desired = desired + forward * 8 - right * side * 5
						end

						local targetVel = target.PrimaryPart.AssemblyLinearVelocity
						local targetSpeed = Vector3.new(targetVel.X, 0, targetVel.Z).Magnitude
						if t >= commitEarliest and hasLOS(npcPos, tgtPos) and (distToTarget() <= 9 or targetSpeed < 4 or strategy == 6) then
							committed = true
							break
						end
						if t >= hardCommit then
							committed = true
							break
						end

						desired = Vector3.new(desired.X, npcPos.Y, desired.Z)
						Path:Run(desired)
						task.wait(0.08)
					end

					if committed and target and target.PrimaryPart then
						local commitEnds = time() + 1.35
						local bias = (math.random() < 0.5) and -1 or 1
						local burst = true
						while humanoid.Health > 0 and target and target.PrimaryPart and time() < commitEnds and distToTarget() > 6.25 do
							if Stunned then break end
							local npcPos = Dummy.PrimaryPart.Position
							local tgtPos = target.PrimaryPart.Position
							local forward = (Vector3.new(tgtPos.X, npcPos.Y, tgtPos.Z) - npcPos).Unit
							local right = Vector3.new(-forward.Z, 0, forward.X)
							local p = math.clamp((commitEnds - time()) / 1.35, 0, 1)
							local stepSide = right * bias * (1.5 + 2.0 * p)
							local commitPos = tgtPos - forward * 5.0 + stepSide
							if burst then
								burst = false
								commitPos = tgtPos - forward * 4.0 + right * bias * 2.5
							end
							commitPos = Vector3.new(commitPos.X, npcPos.Y, commitPos.Z)
							Path:Run(commitPos)
							task.wait(0.055)
						end
					end

					if humanoid.Health > 0 and target and target.PrimaryPart then
						local sidestepBias = (math.random() < 0.5) and -1 or 1
						local npcPos = Dummy.PrimaryPart.Position
						local tgtPos = target.PrimaryPart.Position
						local forward = (Vector3.new(tgtPos.X, npcPos.Y, tgtPos.Z) - npcPos).Unit
						local right = Vector3.new(-forward.Z, 0, forward.X)
						Path:Run(npcPos + right * sidestepBias * 1.75)
						task.wait(0.06 + math.random() * 0.08)

						local track = humanoid:LoadAnimation(attackAnimation)
						track:Play()
						Slash:Play()
						task.wait(0.09 + math.random() * 0.18)

						local inRange = distToTarget() <= 10
						if inRange then
							if Stunned then return end
							local th = target:FindFirstChildOfClass("Humanoid")
							local parry = target:FindFirstChild("Parry")
							if parry and parry:IsA("BoolValue") and parry.Value == true then
								Parry:Play()
								local phrases = {
									"PARRYING ME IS FUTILE.",
									"HERE, CATCH",
									"PREDICTABLE!!",
									"THIS IS.. MASS INFECTION!",
									"HERE COMES MY MASS INFECTION.",
									"IS THAT ALL YOU GOT?"
								}
								local phrase = phrases[math.random(1, #phrases)]
								--game:GetService("Chat"):Chat(Dummy.Head, phrase)
								local npcPos2 = Dummy.PrimaryPart.Position
								local tgtPos2 = target.PrimaryPart.Position
								local back = (Vector3.new(npcPos2.X, 0, npcPos2.Z) - Vector3.new(tgtPos2.X, 0, tgtPos2.Z)).Unit
								Path:Run(npcPos2 + back * 10)
								--CastShockwave()
								task.wait(0.26)
								local blockTool = target:FindFirstChild("Guest")
								if blockTool and blockTool:IsA("Tool") then
									local bindable = blockTool:FindFirstChildWhichIsA("BindableEvent")
									if bindable then
										bindable:Fire()
									end
								end
							elseif th then
								--th:TakeDamage(attackDamage)
								if distToTarget() <= 9 then
									task.wait(0.08 + math.random() * 0.1)

									task.wait(0.06 + math.random() * 0.12)
									if distToTarget() <= 9  then
										local hum = target:FindFirstChildOfClass("Humanoid")
										if not hum then return end
										if hum 
											and hum.Parent 
											and hum.Health > 0 
											and hum.Health - attackDamage <= 0 
											and hum.Parent:FindFirstChildWhichIsA("Tool", true) 
											and hum.Parent:FindFirstChildWhichIsA("Tool", true).Name == "ClassicSword" then
											
											local player  = game.Players:GetPlayerFromCharacter(target)
											if player then
											Socket.emit("DisableResetButton",player)
											end
											targetKilled = true
											target:SetAttribute("Killed",true)
											Path:Stop()
											Dummy.Torso.CanCollide = false
											
											hum.WalkSpeed = 0
											humanoid.WalkSpeed = 0
											local hrp = target:FindFirstChild("HumanoidRootPart")
											if hrp then hrp.CanCollide = false end
											local dummyHum = Dummy:FindFirstChildOfClass("Humanoid")
											if dummyHum then
												local dummyFF = Instance.new("ForceField")
												dummyFF.Visible = false
												dummyFF.Parent = Dummy
												local targetFF = Instance.new("ForceField")
												targetFF.Visible = false
												targetFF.Parent = target
												if hrp and Dummy.PrimaryPart and hum.Parent:FindFirstChild("HumanoidRootPart") then
													local weld = Instance.new("Weld")
													weld.Name = "temp"
													weld.Part0 = Dummy.PrimaryPart
													weld.Part1 = hum.Parent.HumanoidRootPart
													weld.Parent = Dummy.PrimaryPart
												end
												hum.AutoRotate = false
												local originalWalkSpeed = hum.WalkSpeed
												hum.WalkSpeed = 0
												--[[
												 Default below
												 "rbxassetid://76542350389303"
												 "rbxassetid://74568169398549"
												]]
												local finisher = nil
												local victim = nil
												if ragedplayed then
													finisher ="rbxassetid://113218703663864"
													victim =   "rbxassetid://87131722325324"
												else
												finisher ="rbxassetid://76542350389303"
                                                victim =   "rbxassetid://74568169398549"
												end
												local victimAnim = Instance.new("Animation")
												victimAnim.AnimationId = victim
												local victimTrack = hum:LoadAnimation(victimAnim)
												local killerAnim = Instance.new("Animation")
												killerAnim.AnimationId = finisher
												local killerTrack = dummyHum:LoadAnimation(killerAnim)
												victimTrack:Play()
												killerTrack:Play()
												Dummy.PrimaryPart.Anchored = true
												if ragedplayed then
													Dummy.Special2:Play()
												else
													Dummy.Special:Play()
												end
												Dummy.Torso.CanCollide = false
												victimTrack.Stopped:Connect(function()
													Dummy.PrimaryPart:FindFirstChild("temp"):Destroy()
													hrp.Anchored = false
													hrp.CanCollide = true
													if targetFF then targetFF:Destroy() end
													hum:TakeDamage(hum.Health)
													hum.AutoRotate = true
													hum.WalkSpeed = originalWalkSpeed
												end)
												killerTrack.Stopped:Connect(function()
													local phrases = {
													"NEXT."
													}
													local phrase = phrases[math.random(1, #phrases)]
													
														--game:GetService("Chat"):Chat(Dummy.Head, phrase)
													
													Dummy.PrimaryPart.Anchored = false
													Dummy.Torso.CanCollide = true
													targetKilled = false
													humanoid.WalkSpeed = 28
													if dummyFF then dummyFF:Destroy() end
												end)
											end
										else
											th:TakeDamage(attackDamage)
											humanoid.Health = math.min(humanoid.MaxHealth, humanoid.Health + attackDamage)
										end
									end

								end
							end

						else
							local npcPos4 = Dummy.PrimaryPart.Position
							local tgtPos4 = target.PrimaryPart.Position
							local forward4 = (Vector3.new(tgtPos4.X, 0, tgtPos4.Z) - Vector3.new(npcPos4.X, 0, npcPos4.Z)).Unit
							local right4 = Vector3.new(-forward4.Z, 0, forward4.X)
							Path:Run(npcPos4 - forward4 * 6 + right4 * ((math.random() < 0.5) and -1 or 1) * 5)
							task.wait(0.18)
						end

						--track:Stop()
					end

					attacking = false
				end)



				-- CASTING SHOCKWAVE LOGIC
			elseif dist < 55 and math.random() < 0.005 and not (throwing or raged or targetKilled or Stunned) then
				Path:Stop()
				local phrases = {
					"Prepare to get sogged!",
					"Dodge this if ur a soggy cat",
					"sogging!"
				}
				local phrase = phrases[math.random(1, #phrases)]
				if math.random() < 0.010 then
					--game:GetService("Chat"):Chat(Dummy.Head, phrase)
				end
				casting = true
				local target = nearestCharacter
				task.spawn(function()
					print("spawned2")
					castTrack:Play()
					Infect:Play()
					local hrp = Dummy:FindFirstChild("HumanoidRootPart")

					task.wait(1.3)

					task.wait(0.4)

					if Dummy and Dummy.PrimaryPart then
						local function interceptDir(shooterPos, projectileSpeed, targetPos, targetVel)
							shooterPos = Vector3.new(shooterPos.X, 0, shooterPos.Z)
							targetPos = Vector3.new(targetPos.X, 0, targetPos.Z)
							targetVel = Vector3.new(targetVel.X, 0, targetVel.Z)
							local r = targetPos - shooterPos
							local v = targetVel
							local vv = v:Dot(v)
							local s2 = projectileSpeed * projectileSpeed
							local a = vv - s2
							local b = 2 * r:Dot(v)
							local c = r:Dot(r)
							local t
							if math.abs(a) < 1e-3 then
								if math.abs(b) < 1e-3 then
									t = 0
								else
									t = math.max(-c / b, 0)
								end
							else
								local disc = b * b - 4 * a * c
								if disc < 0 then
									t = 0
								else
									local sqrtDisc = math.sqrt(disc)
									local t1 = (-b - sqrtDisc) / (2 * a)
									local t2 = (-b + sqrtDisc) / (2 * a)
									if t1 > 0 and t2 > 0 then
										t = math.min(t1, t2)
									elseif t1 > 0 then
										t = t1
									elseif t2 > 0 then
										t = t2
									else
										t = 0
									end
								end
							end
							local aimPos = targetPos + v * t
							local dir = aimPos - shooterPos
							if dir.Magnitude < 1e-3 then
								return r.Unit
							end
							return dir.Unit
						end
						local function rotateY(v, ang)
							local c = math.cos(ang)
							local s = math.sin(ang)
							return Vector3.new(v.X * c - v.Z * s, 0, v.X * s + v.Z * c).Unit
						end
						local function fireShockwave(dir, curveOffset, delay, speed, duration, steps)
							if Stunned then return end
							task.spawn(function()
								if delay and delay > 0 then task.wait(delay) end

								local shockwave = Shockwave:Clone()
								shockwave.Parent = workspace
								if not shockwave.PrimaryPart then shockwave:Destroy() return end

								shockwave.PrimaryPart.Anchored = true
								shockwave:SetPrimaryPartCFrame(Dummy.PrimaryPart.CFrame)

								local collider = Instance.new("Part")
								collider.Size = shockwave.PrimaryPart.Size
								collider.Transparency = 1
								collider.Anchored = false
								collider.CanCollide = false
								collider.CanTouch = true
								collider.Position = shockwave.PrimaryPart.Position
								collider.Parent = workspace

								local weld = Instance.new("Weld")
								weld.Part0 = collider
								weld.Part1 = shockwave.PrimaryPart
								weld.Parent = collider

								local touchedPlayers = {}
								collider.Touched:Connect(function(hit)
									local character = hit:FindFirstAncestorWhichIsA("Model")
									if character and character ~= Dummy and not touchedPlayers[character] then
										local hum = character:FindFirstChildOfClass("Humanoid")
										if hum then
											touchedPlayers[character] = true

											local HRP = character:FindFirstChild("HumanoidRootPart")
											if HRP then
												local knockback = {}
												knockback.Direction = -HRP.CFrame.LookVector
												knockback.Strength = 60

												local player = game.Players:GetPlayerFromCharacter(character)
												if player then
													if ragedplayed then
														if hum.Parent:GetAttribute("NPC") then return end

														humanoid.Health = math.min(humanoid.MaxHealth, humanoid.Health + shockwavedmg)
													end
													hum:TakeDamage(shockwavedmg)
													Ragdoll:Ragdoll(character, knockback, 3)
													
													--
												else
													if character.Name == "AudZombie" then
														--hum.Health = 0
													else
														hum:TakeDamage(shockwavedmg)
													end
												end
											else
												hum:TakeDamage(shockwavedmg)
												
											end
										end
									end
								end)

								local damageCube = Instance.new("Part")
								damageCube.Size = Vector3.new(10, 10, 10) 
								damageCube.CFrame = Dummy.PrimaryPart.CFrame
								damageCube.Transparency = 1
								damageCube.Anchored = false
								damageCube.CanCollide = false
								damageCube.CanTouch = true
								damageCube.Name = "DamageCube"
								damageCube.Parent = workspace

								local weldCube = Instance.new("Weld")
								weldCube.Part0 = damageCube
								weldCube.Part1 = Dummy.PrimaryPart
								weldCube.C0 = CFrame.new()
								weldCube.C1 = CFrame.new()
								weldCube.Parent = damageCube

								local alreadyDamaged = {}
								damageCube.Touched:Connect(function(hit)
									local character = hit:FindFirstAncestorWhichIsA("Model")
									if character and character ~= Dummy and not alreadyDamaged[character] then
										local hum = character:FindFirstChildOfClass("Humanoid")
										if hum then
											alreadyDamaged[character] = true
											hum:TakeDamage(70)
										end
									end
								end)

								task.delay(0.2, function()
									if damageCube then
										damageCube:Destroy()
									end
								end)

								local RunService = game:GetService("RunService")
								local startCf = shockwave:GetPivot()
								local totalTime = duration
								local startPos = startCf.Position
								local endPos = startPos + dir * (speed * totalTime)
								local controlPos = (curveOffset and (startPos + dir * (speed * totalTime * 0.5) + curveOffset)) or nil
								local lastPos = startPos
								local elapsed = 0
								local conn
								conn = RunService.Heartbeat:Connect(function(dt)
									elapsed += dt
									local a = math.clamp(elapsed / totalTime, 0, 1)
									local pos
									if controlPos then
										local u = 1 - a
										pos = u*u*startPos + 2*u*a*controlPos + a*a*endPos
									else
										pos = startPos:Lerp(endPos, a)
									end
									local nextA = math.clamp(a + 0.02, 0, 1)
									local nextPos
									if controlPos then
										local u2 = 1 - nextA
										nextPos = u2*u2*startPos + 2*u2*nextA*controlPos + nextA*nextA*endPos
									else
										nextPos = startPos:Lerp(endPos, nextA)
									end
									local forward = (nextPos - pos)
									if forward.Magnitude < 1e-4 then forward = dir end
									local look = CFrame.new(pos, pos + forward.Unit)
									shockwave:PivotTo(look)
									local vel = (pos - lastPos) / math.max(dt, 1/240)
									collider.AssemblyLinearVelocity = Vector3.new(vel.X, 0, vel.Z)
									lastPos = pos
									if a >= 1 then
										collider.AssemblyLinearVelocity = Vector3.zero
										if conn then conn:Disconnect() end
									end
								end)
								game:GetService("Debris"):AddItem(shockwave, 3)
							end)
						end
						local speed = 80
						local duration = 1.5
						local steps = 30

						local facing = Vector3.new(Dummy.PrimaryPart.CFrame.LookVector.X, 0, Dummy.PrimaryPart.CFrame.LookVector.Z).Unit
						local baseDir = facing
						local right = Vector3.new(-baseDir.Z, 0, baseDir.X).Unit

						local pattern = math.random(1,4)
						if pattern == 1 then
							fireShockwave(baseDir, nil, 0, speed, duration, steps)
						elseif pattern == 2 then
							local side = (math.random() < 0.5) and -1 or 1
							local dirA = rotateY(baseDir, math.rad(18) * side)
							fireShockwave(dirA, nil, 0, speed, duration, steps)
						elseif pattern == 3 then
							fireShockwave(baseDir, nil, 0, speed, duration, steps)
						elseif pattern == 4 then
							local side = (math.random() < 0.5) and -1 or 1
							local curve = right * side * 12
							fireShockwave(baseDir, curve, 0, speed, duration, steps)
						end
					end


					castTrack.Stopped:Wait()
					casting = false
				end)
			elseif dist < 100 and math.random() < 0.005 and not targetKilled then

				task.spawn(function()
					if not nearestCharacter then return end
					local hrp = nearestCharacter:FindFirstChild("HumanoidRootPart")
					if not hrp then return end

					local rcParams = RaycastParams.new()
					rcParams.FilterType = Enum.RaycastFilterType.Exclude
					rcParams.FilterDescendantsInstances = { Dummy }

					local function findFloorSpot()
						for i = 1, 12 do
							local angle = math.random() * math.pi * 2
							local d = math.random(6, 15) 
							local offset = Vector3.new(math.cos(angle) * d, 0, math.sin(angle) * d)
							local start = hrp.Position + offset + Vector3.new(0, 60, 0)
							local result = workspace:Raycast(start, Vector3.new(0, -120, 0), rcParams)
							if result and result.Normal.Y > 0.7 then
								return result.Position
							end
						end
						return nil
					end

					local pos = findFloorSpot()
					if not pos then return end

					local radius = 10
					local segmentCount = 32
					local circleFolder = Instance.new("Folder")
					circleFolder.Name = "WarningCircleSegments"
					circleFolder.Parent = workspace

					local initialRadius = 1
					local maxRadius = radius
					local expandTime = 1
					local steps = 30
					local radiusStep = (maxRadius - initialRadius) / steps
					local waitTime = expandTime / steps

					for step = 1, steps do
						local currentRadius = initialRadius + radiusStep * (step - 1)
						circleFolder:ClearAllChildren()
						for i = 1, segmentCount do
							local angle = (2 * math.pi / segmentCount) * i
							local offset = Vector3.new(math.cos(angle) * currentRadius, 0, math.sin(angle) * currentRadius)
							local part = Instance.new("Part")
							part.Size = Vector3.new(1, 0.2, 1)
							part.Anchored = true
							part.CanCollide = false
							part.CanQuery = false
							part.Material = Enum.Material.Neon
							part.Color = Color3.fromRGB(0, 0, 0)
							part.CFrame = CFrame.new(pos + offset + Vector3.new(0, 0.1, 0))
							part.Parent = circleFolder
						end
						task.wait(waitTime)
					end

					circleFolder:Destroy()

					local beam = game.ReplicatedStorage.Templates:WaitForChild("AudBeam"):Clone()
					beam.Name = "RedBeam"
					beam.Anchored = true
					beam.CanCollide = false
					beam.CanQuery = false
					beam.Transparency = 0.15

					local beamHeight = 120
					local growTime = 0.4
					local fps = 60
					local initialHeight = 0.1

					beam.Size = Vector3.new(radius * 2, initialHeight, radius * 2)
					beam.CFrame = CFrame.new(pos + Vector3.new(0, initialHeight / 2, 0)) * CFrame.Angles(0, 0, math.rad(0))
					beam.Parent = workspace

					local growSteps = math.floor(fps * growTime)
					for i = 1, growSteps do
						local alpha = i / growSteps
						local currentHeight = initialHeight + (beamHeight - initialHeight) * alpha
						beam.Size = Vector3.new(radius * 2, currentHeight, radius * 2)
						beam.CFrame = CFrame.new(pos + Vector3.new(0, currentHeight / 2, 0)) * CFrame.Angles(0, 0, math.rad(0))
						RunService.Heartbeat:Wait()
					end



					beam.Touched:Connect(function(hit)
						local character = hit.Parent
						if not character then return end

						local hum = character:FindFirstChildOfClass("Humanoid")
						local HRP = character:FindFirstChild("HumanoidRootPart")
						if not hum or not HRP then return end
						if character == Dummy then return end

						if damaged[hum] then return end
						damaged[hum] = true

						local knockback = {}
						knockback.Direction = (-HRP.CFrame.LookVector + Vector3.new(0, 1, 0)).Unit
						knockback.Strength = 100

						if character.Name == "AudZombie" then
							--hum:TakeDamage(100)
						else
							hum:TakeDamage(30)
							Ragdoll:Ragdoll(character, knockback, 3)
						end

						task.delay(0.5, function()
							damaged[hum] = nil
						end)
					end)

					game:GetService("Debris"):AddItem(beam, 0.6)
					game:GetService("Debris"):AddItem(circleFolder, 0.6)
				end)
			elseif dist < 50 and math.random() < 0.005 and ragedplayed and not targetKilled then
				print("doing grounded random beam placemend")
				task.spawn(function()
					local hrp = Dummy:FindFirstChild("HumanoidRootPart")
					if not hrp then return end

					-- Number of beams to spawn in the attack
					local beamCount = 8

					-- Radius (in studs) of each beam's area of effect and warning circle
					local radius = 10

					-- Number of visual segments that make up the warning circle (higher = smoother circle)
					local segmentCount = 32

					-- Minimum allowed distance (in studs) between each beam's center to avoid clustering
					local minSeparation = 15

					-- Table to track positions already used, for spacing comparison
					local usedPositions = {}

					local rcParams = RaycastParams.new()
					rcParams.FilterType = Enum.RaycastFilterType.Exclude
					rcParams.FilterDescendantsInstances = { Dummy }

					local function findFloorSpot()
						for i = 1, 20 do
							local angle = math.random() * math.pi * 2
							local d = math.random(6, 15)
							local offset = Vector3.new(math.cos(angle) * d, 0, math.sin(angle) * d)
							local start = hrp.Position + offset + Vector3.new(0, 60, 0)
							local result = workspace:Raycast(start, Vector3.new(0, -120, 0), rcParams)
							if result and result.Normal.Y > 0.7 then
								local pos = result.Position
								local tooClose = false
								for _, prev in ipairs(usedPositions) do
									if (prev - pos).Magnitude < minSeparation then
										tooClose = true
										break
									end
								end
								if not tooClose then
									table.insert(usedPositions, pos)
									return pos
								end
							end
						end
						return nil
					end

					for i = 1, beamCount do
						task.spawn(function()
							local pos = findFloorSpot()
							if not pos then return end

							local circleFolder = Instance.new("Folder")
							circleFolder.Name = "WarningCircleSegments"
							circleFolder.Parent = workspace

							local initialRadius = 1
							local maxCircleRadius = radius
							local expandTime = 1
							local steps = 30
							local radiusStep = (maxCircleRadius - initialRadius) / steps
							local waitTime = expandTime / steps

							for step = 1, steps do
								local currentRadius = initialRadius + radiusStep * (step - 1)
								circleFolder:ClearAllChildren()
								for j = 1, segmentCount do
									local segAngle = (2 * math.pi / segmentCount) * j
									local segOffset = Vector3.new(math.cos(segAngle) * currentRadius, 0, math.sin(segAngle) * currentRadius)
									local part = Instance.new("Part")
									part.Size = Vector3.new(1, 0.2, 1)
									part.Anchored = true
									part.CanCollide = false
									part.CanQuery = false
									part.Material = Enum.Material.Neon
									part.Color = Color3.fromRGB(0, 0, 0)
									part.CFrame = CFrame.new(pos + segOffset + Vector3.new(0, 0.1, 0))
									part.Parent = circleFolder
								end
								task.wait(waitTime)
							end

							circleFolder:Destroy()

							local beam = game.ReplicatedStorage.Templates:WaitForChild("AudBeam"):Clone()
							beam.Name = "RedBeam"
							beam.Anchored = true
							beam.CanCollide = false
							beam.CanQuery = false
							beam.Transparency = 0.15

							local beamHeight = 120
							local growTime = 0.4
							local fps = 60
							local initialHeight = 0.1

							beam.Size = Vector3.new(radius * 2, initialHeight, radius * 2)
							beam.CFrame = CFrame.new(pos + Vector3.new(0, initialHeight / 2, 0))
							beam.Parent = workspace

							for s = 1, math.floor(fps * growTime) do
								local alpha = s / (fps * growTime)
								local currentHeight = initialHeight + (beamHeight - initialHeight) * alpha
								beam.Size = Vector3.new(radius * 2, currentHeight, radius * 2)
								beam.CFrame = CFrame.new(pos + Vector3.new(0, currentHeight / 2, 0))
								RunService.Heartbeat:Wait()
							end

							beam.Touched:Connect(function(hit)
								local character = hit.Parent
								if not character then return end

								local hum = character:FindFirstChildOfClass("Humanoid")
								local HRP = character:FindFirstChild("HumanoidRootPart")
								if not hum or not HRP then return end
								if character == Dummy then return end

								if damaged[hum] then return end
								damaged[hum] = true

								local knockback = {}
								knockback.Direction = (-HRP.CFrame.LookVector + Vector3.new(0, 1, 0)).Unit
								knockback.Strength = 100

								if character.Name == "AudZombie" then
									--hum:TakeDamage(100)
								else
									hum:TakeDamage(30)
									Ragdoll:Ragdoll(character, knockback, 3)
								end

								task.delay(0.5, function()
									damaged[hum] = nil
								end)
							end)

							game:GetService("Debris"):AddItem(beam, 0.6)
							game:GetService("Debris"):AddItem(circleFolder, 0.6)
						end)
					end
					table.clear(usedPositions)
				end)








				-- ENTANGLEMENT LOGIC
			elseif dist < 45 and math.random() < 0.005 and not (casting or raged or targetKilled or Stunned) then
				Path:Stop()
				throwing = true
				local target = nearestCharacter

				task.spawn(function()
					print("spawned3")
					local castTrack = humanoid:LoadAnimation(throwanimation)
					castTrack:Play()
					--Infect:Play()

					task.wait(0.75)

					if Dummy and Dummy.PrimaryPart then
						local shockwave = Swords:Clone()
						shockwave.Parent = workspace



						if shockwave.PrimaryPart then
							shockwave.PrimaryPart.Anchored = true
							shockwave:SetPrimaryPartCFrame(Dummy.PrimaryPart.CFrame)

							local direction = Dummy.PrimaryPart.CFrame.LookVector.Unit
							local speed = 80
							local duration = 1.5
							local steps = 30
							local stepTime = duration / steps


							local collider = Instance.new("Part")
							collider.Size = Shockwave.PrimaryPart.Size
							collider.Transparency = 1
							collider.Anchored = false
							collider.CanCollide = false
							collider.CanTouch = true
							collider.Position = shockwave.PrimaryPart.Position
							collider.Parent = workspace

							local weld = Instance.new("Weld")
							weld.Part0 = collider
							weld.Part1 = shockwave.PrimaryPart
							weld.Parent = collider

							local originalStates = {}

							collider.Touched:Connect(function(hit)

								local character = hit:FindFirstAncestorWhichIsA("Model")

								if character and character ~= Dummy and not touchedPlayers2[character.Name] then
									local hum = character:FindFirstChildOfClass("Humanoid")
									local hrp = character:FindFirstChild("HumanoidRootPart")
									local torso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")

									if hum and hrp and torso then
										touchedPlayers2[character.Name] = true
										hum:TakeDamage(entangledmg)
										if ragedplayed then
											if hum.Parent:GetAttribute("NPC") then return end
										humanoid.Health = math.min(humanoid.MaxHealth, humanoid.Health + attackDamage)
										end

										if not originalStates[character] then
											originalStates[character] = {
												speed = hum.WalkSpeed,
												jump = hum.JumpPower,
											}
										end

										local knockback = {
											Direction = -hrp.CFrame.LookVector,
											Strength = 60,
										}

										local player = Players:GetPlayerFromCharacter(character)
										if player then
											Ragdoll:Ragdoll(character, knockback, 3)
										end

										task.delay(1, function()
											if hum and originalStates[character] then
												touchedPlayers2[character.Name] = nil 
											end
										end)
									end
								end
							end)


							local totalTime = 1 
							local elapsed = 0
							local targetSpeed = 120 

							task.spawn(function()
								local lastTick = tick()
								while elapsed < totalTime and shockwave and shockwave.PrimaryPart do
									local now = tick()
									local dt = now - lastTick
									lastTick = now
									elapsed += dt

									local moveOffset = direction * targetSpeed * dt
									local currentCFrame = shockwave.PrimaryPart.CFrame
									shockwave:SetPrimaryPartCFrame(currentCFrame + moveOffset)
									collider.Velocity = moveOffset / dt

									RunService.Heartbeat:Wait()
								end

								if collider then collider:Destroy() end
								if shockwave then shockwave:Destroy() end
							end)


							game:GetService("Debris"):AddItem(shockwave, 3)
						end
					end


					throwing = false
				end)

				-- OI OI LOGIC
			elseif dist < 80 and math.random() < 0.005 and not lastmanstanding then

				task.spawn(function()
					if getConnectionCount() >= 6 then return end
					print("Zombie Spawned!")
					
					local function findFloorSpot()
						local rcParams = RaycastParams.new()
						rcParams.FilterType = Enum.RaycastFilterType.Exclude
						rcParams.FilterDescendantsInstances = { Dummy, Zombie }

						for i = 1, 12 do
							local angle = math.random() * math.pi * 2
							local d = math.random(12, 50)
							local offset = Vector3.new(math.cos(angle) * d, 0, math.sin(angle) * d)
							local start = Dummy.PrimaryPart.Position + offset + Vector3.new(0, 60, 0)
							local result = workspace:Raycast(start, Vector3.new(0, -120, 0), rcParams)
							if result and result.Normal.Y > 0.7 then
								return result.Position
							end
						end
						return nil
					end

					local pos = findFloorSpot()
					if pos then
						local z = Zombie:Clone()
						z.Parent = workspace.NPCs
						Socket.emit("Activation",z)

						local root = z:FindFirstChild("HumanoidRootPart") or z.PrimaryPart
						if root then
							local hum = z:FindFirstChildOfClass("Humanoid")
							local yOffset = hum and (hum.HipHeight + root.Size.Y * 0.5) or (root.Size.Y * 0.5)
							z:PivotTo(CFrame.new(pos + Vector3.new(0, yOffset + 0.1, 0) + Vector3.new(0, 3, 0)))
						end
						registerNPC(z)
						local circle = ReplicatedStorage.Templates:FindFirstChild("AudSpawn"):Clone()
						circle.Parent = workspace
						circle.CFrame = CFrame.new(pos + Vector3.new(0, 0.1, 0))


						circle.Touched:Connect(function(hit)
							local character = hit.Parent
							if not character then return end

							local hum = character:FindFirstChildOfClass("Humanoid")
							local HRP = character:FindFirstChild("HumanoidRootPart")
							if not hum or not HRP then return end

							local player = Players:GetPlayerFromCharacter(character)
							if not player then return end

							for _, part in ipairs(character:GetDescendants()) do
								if part:IsA("BasePart") then
									part.CanCollide = false
								end
							end

							local bp = Instance.new("BodyPosition")
							bp.MaxForce = Vector3.new(1e6, 1e6, 1e6)
							bp.P = 20000
							bp.D = 2000
							bp.Position = circle.Position - Vector3.new(0, 5, 0)
							bp.Parent = HRP

							task.delay(1.2, function()
								bp:Destroy()
								local FF = character:FindFirstChildWhichIsA("ForceField")
								--if FF then FF:Destroy() end
								
								hum:TakeDamage(120)
							end)
						end)



						game:GetService("Debris"):AddItem(circle, 10)



					end

					task.wait(1)
					--spawning = false
				end)
			elseif dist < 120 and math.random() < 0.005 and ragedplayed and not (spawning or raged or targetKilled or getConnectionCount() >= 6 or lastmanstanding) then
				Path:Stop()
				spawning = true
				lastSpawn = time()
				local RageTrack = humanoid:LoadAnimation(RageAnimation2)
				RageTrack:Play()
				task.wait(0.5)
				RTR:Play()

				


				



				task.spawn(function()


					local rcParams = RaycastParams.new()
					rcParams.FilterType = Enum.RaycastFilterType.Exclude
					rcParams.FilterDescendantsInstances = { Dummy, Zombie }

					local triangleRadius = 20
					local angleOffset = math.random() * math.pi * 2

					local sourcePool = {
						game.ServerStorage.NPCS:WaitForChild("AudZombie"),
						game.ServerStorage.NPCS:WaitForChild("AudZombie2"),
						--game.ServerStorage.NPCS:WaitForChild("AudJug"),
					}

					local hasJug = false
					local npcPool = {}

					while #npcPool < 3 do
						local pick = sourcePool[math.random(1, #sourcePool)]
						if pick.Name == "AudJug" then
							if not hasJug then
								table.insert(npcPool, pick)
								hasJug = true
							end
						else
							table.insert(npcPool, pick)
						end
					end

					for i = #npcPool, 2, -1 do
						local j = math.random(1, i)
						npcPool[i], npcPool[j] = npcPool[j], npcPool[i]
					end

					local currentCount = getConnectionCount()
					local toSpawn = math.clamp(6 - currentCount, 0, 3)

					for i = 0, toSpawn - 1 do
						local angle = angleOffset + i * (2 * math.pi / 3)
						local offset = Vector3.new(math.cos(angle) * triangleRadius, 0, math.sin(angle) * triangleRadius)
						local start = Dummy.PrimaryPart.Position + offset + Vector3.new(0, 60, 0)
						local result = workspace:Raycast(start, Vector3.new(0, -120, 0), rcParams)

						if result and result.Normal.Y > 0.7 then
							local trianglePos = result.Position
							local npcTemplate = npcPool[i + 1]
							local zClone = npcTemplate:Clone()
							zClone.Parent = workspace

							local root = zClone:FindFirstChild("HumanoidRootPart") or zClone.PrimaryPart
							if root then
								local hum = zClone:FindFirstChildOfClass("Humanoid")
								local yOffset = hum and (hum.HipHeight + root.Size.Y * 0.5) or (root.Size.Y * 0.5)
								zClone:PivotTo(CFrame.new(trianglePos + Vector3.new(0, yOffset + 0.1, 0)))
							end

							zClone.PrimaryPart:SetNetworkOwner(nil)
							registerNPC(zClone)
							Socket.emit("Activation",zClone)
							local Players = game:GetService("Players")
							local circle = ReplicatedStorage.Templates:FindFirstChild("AudSpawn"):Clone()
							circle.Parent = workspace
							circle.CFrame = CFrame.new(trianglePos + Vector3.new(0, 0.1, 0))

							circle.Touched:Connect(function(hit)
								local character = hit.Parent
								if not character then return end
								local hum = character:FindFirstChildOfClass("Humanoid")
								local HRP = character:FindFirstChild("HumanoidRootPart")
								if not hum or not HRP then return end
								local player = Players:GetPlayerFromCharacter(character)
								if not player then return end
								for _, part in ipairs(character:GetDescendants()) do
									if part:IsA("BasePart") then
										part.CanCollide = false
									end
								end
								local bp = Instance.new("BodyPosition")
								bp.MaxForce = Vector3.new(1e6, 1e6, 1e6)
								bp.P = 20000
								bp.D = 2000
								bp.Position = circle.Position - Vector3.new(0, 5, 0)
								bp.Parent = HRP
								task.delay(1.2, function()
									bp:Destroy()
									local FF = character:FindFirstChildWhichIsA("ForceField")
									--if FF then FF:Destroy() end
									
									hum:TakeDamage(120)
								end)
							end)

							game:GetService("Debris"):AddItem(circle, 10)
						end
					end
					


					RageTrack.Stopped:Connect(function()
						spawning = false
						end)
					end)



			elseif not (raged or casting or throwing or spawning or targetKilled or Stunned) then
				local toTarget = (targetPos - npcPos)
				if toTarget.Magnitude < 1e-3 then return end
				local forward = toTarget.Unit
				local right = Vector3.new(-forward.Z, 0, forward.X)
				local t = time()

				local dist = toTarget.Magnitude
				local closing = math.clamp((20 - dist) / 20, 0, 1)

				local orbitRadius = 20 + 10 * math.noise(t * 0.7 + 10) + 18 * closing
				local strafeAmp = 18 + 10 * closing

				local lateral = math.clamp(math.noise(t * 1.2), -1, 1)
				local sidePulse = (math.noise(t * 0.6, 2) >= 0) and 1 or -1

				local fn = math.noise(t * 3.0)
				local feint = (fn > 0.25) and 1 or ((fn < -0.25) and -1 or 0)
				local feintAmp = 10 + 10 * closing

				local offset = right * (lateral * strafeAmp * sidePulse)
					+ forward * (feint * feintAmp - orbitRadius)

				local swirl = right * (math.sin(t * 1.6) * 8) + forward * (math.cos(t * 1.6) * -4)
				offset += swirl
				offset += Vector3.new(
					math.noise(t * 6.0, 1) * (4 + 2 * closing),
					0,
					math.noise(t * 6.0, 2) * (4 + 2 * closing)
				)

				local burstGate = math.noise(t * 3.2, 7)
				local burst = (burstGate > 0.6) and 1 or 0
				offset += forward * (burst * (10 + 10 * closing)) + right * (burst * sidePulse * 5)

				local desiredPos = targetPos + offset
				desiredPos = Vector3.new(desiredPos.X, npcPos.Y, desiredPos.Z)

				local toDesired = desiredPos - npcPos
				if toDesired.Magnitude > 1e-3 then
					local overshoot = toDesired.Unit * math.clamp(6 + 8 * closing, 6, 14)
					desiredPos += overshoot
				end

				if dist < 12 then
					local escapeMag = 18 + 12 * math.abs(math.noise(t * 1.7))
					local side = (math.noise(t * 1.3, 3) >= 0) and 1 or -1
					local escape = (-forward * escapeMag) + right * side * (10 + 4 * closing)
					desiredPos += escape
				end

				Path:Run(desiredPos)
			end

		else
			Path:Run(goal)
		end
	end

	if nearestCharacter and nearestCharacter.PrimaryPart and not (targetKilled or Stunned) then
		local npcPos = Dummy.PrimaryPart.Position
		local targetPos = nearestCharacter.PrimaryPart.Position

		targetPos = Vector3.new(targetPos.X, npcPos.Y, targetPos.Z)

		bodyGyro.CFrame = CFrame.new(npcPos, targetPos)
	end
end)


function death()
	connection:Disconnect()
	--if RunService:IsStudio() then
	--ReplicatedStorage.Remotes.TriggerAudEnd:Fire()
	--end

	Dummy.Humanoid.Archivable = true
	local zombiecorpse = Dummy:Clone()

	local weldConstraints = {}
	for _, weld in ipairs(zombiecorpse:GetDescendants()) do
		if weld:IsA("WeldConstraint") then
			table.insert(weldConstraints, {
				weld = weld,
				part0 = weld.Part0,
				part1 = weld.Part1
			})
		end
	end

	for _, descendant in ipairs(zombiecorpse:GetDescendants()) do
		if (descendant:IsA("Script") or descendant:IsA("LocalScript")) and descendant.Name ~= "balls" then
			descendant:Destroy()
		end
	end
	Dummy:Destroy()
	for _, data in ipairs(weldConstraints) do
		local weld = data.weld
		if data.part0 and data.part1 then
			weld.Part0 = data.part0
			weld.Part1 = data.part1
			weld.Enabled = true

		end
	end
	zombiecorpse.Parent = workspace



	zombiecorpse.Head.EyesV2:Destroy()
	zombiecorpse.Head.AudiHalo.Parent = workspace
	workspace.AudiHalo.balls.Enabled = true
	local Humanoid = zombiecorpse:FindFirstChildOfClass("Humanoid")
	local Torso = zombiecorpse:FindFirstChild("Torso")
	Humanoid.PlatformStand = true
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
	for _, v in pairs(Torso:GetChildren()) do
		if v:IsA("Motor6D") or v:IsA("Weld") then
			v:Destroy()
		end
	end
	for _, v in pairs(zombiecorpse.Head:GetChildren()) do
		if v:IsA("Weld") then
			v:Destroy()
		end
	end
	for _, v in pairs(zombiecorpse:GetChildren()) do
		if v:IsA("Part") then
			for _, w in pairs(v:GetChildren()) do
				if w:IsA("BodyPosition") or w:IsA("BodyVelocity") then
					w:Destroy()
				end
			end
		end
	end
	local function makeconnections(limb, attachementone, attachmenttwo, twistlower, twistupper, upperangle)
		local connection = Instance.new("BallSocketConstraint", limb)
		connection.LimitsEnabled = true
		connection.Attachment0 = attachementone
		connection.Attachment1 = attachmenttwo
		connection.TwistLimitsEnabled = true
		connection.TwistLowerAngle = twistlower
		connection.TwistUpperAngle = twistupper
		connection.UpperAngle = 70
	end
	local function makehingeconnections(limb, attachementone, attachmenttwo, twistlower, twistupper, upperangle)
		local connection = Instance.new("HingeConstraint", limb)
		connection.Attachment0 = attachementone
		connection.Attachment1 = attachmenttwo
		connection.LimitsEnabled = true
		connection.LowerAngle = twistlower
		connection.UpperAngle = twistupper
	end
	Humanoid.Parent["Right Arm"].RightShoulderAttachment.Position = Vector3.new(0, 0.5, 0)
	Torso.RightCollarAttachment.Position = Vector3.new(1.5, 0.5, 0)
	Humanoid.Parent["Left Arm"].LeftShoulderAttachment.Position = Vector3.new(0, 0.5, 0)
	Torso.LeftCollarAttachment.Position = Vector3.new(-1.5, 0.5, 0)
	local RightLegAttachment = Instance.new("Attachment", Humanoid.Parent["Right Leg"])
	RightLegAttachment.Position = Vector3.new(0, 1, 0)
	local TorsoRightLegAttachment = Instance.new("Attachment", Torso)
	TorsoRightLegAttachment.Position = Vector3.new(0.5, -1, 0)
	local LeftLegAttachment = Instance.new("Attachment", Humanoid.Parent["Left Leg"])
	LeftLegAttachment.Position = Vector3.new(0, 1, 0)
	local TorsoLeftLegAttachment = Instance.new("Attachment", Torso)
	TorsoLeftLegAttachment.Position = Vector3.new(-0.5, -1, 0)
	if Humanoid.Parent:FindFirstChild("Head") then
		local HeadAttachment = Instance.new("Attachment", Humanoid.Parent.Head)
		HeadAttachment.Position = Vector3.new(0, -0.5, 0)
		makehingeconnections(Humanoid.Parent.Head, HeadAttachment, Torso.NeckAttachment, -20, 20, 70)
	end
	makeconnections(Humanoid.Parent["Right Arm"], Humanoid.Parent["Right Arm"].RightShoulderAttachment, Torso.RightCollarAttachment, -80, 80)
	makeconnections(Humanoid.Parent["Left Arm"], Humanoid.Parent["Left Arm"].LeftShoulderAttachment, Torso.LeftCollarAttachment, -80, 80)
	makeconnections(Humanoid.Parent["Right Leg"], RightLegAttachment, TorsoRightLegAttachment, -80, 80, 70)
	makeconnections(Humanoid.Parent["Left Leg"], LeftLegAttachment, TorsoLeftLegAttachment, -80, 80, 70)
	if Humanoid.Parent:FindFirstChild("Right Arm") then
		local limbcollider = Instance.new("Part", Humanoid.Parent["Right Arm"])
		limbcollider.Size = Vector3.new(1,1.3,1)
		limbcollider.Shape = "Cylinder"
		limbcollider.Transparency = 1
		local limbcolliderweld = Instance.new("Weld", limbcollider)
		limbcolliderweld.Part0 = Humanoid.Parent["Right Arm"]
		limbcolliderweld.Part1 = limbcollider
		limbcolliderweld.C0 = CFrame.fromEulerAnglesXYZ(0,0,math.pi/2) * CFrame.new(-0.4,0,0)
		for _, v in pairs(zombiecorpse["Right Arm"]:GetChildren()) do
			if v:IsA("Motor6D") or v:IsA("Weld") then
				v:Destroy()
			end
		end
	end
	if Humanoid.Parent:FindFirstChild("Left Arm") then
		local limbcollider = Instance.new("Part", Humanoid.Parent["Left Arm"])
		limbcollider.Size = Vector3.new(1,1.3,1)
		limbcollider.Shape = "Cylinder"
		limbcollider.Transparency = 1
		local limbcolliderweld = Instance.new("Weld", limbcollider)
		limbcolliderweld.Part0 = Humanoid.Parent["Left Arm"]
		limbcolliderweld.Part1 = limbcollider
		limbcolliderweld.C0 = CFrame.fromEulerAnglesXYZ(0,0,math.pi/2) * CFrame.new(-0.4,0,0)
	end
	if Humanoid.Parent:FindFirstChild("Left Leg") then
		local limbcollider = Instance.new("Part", Humanoid.Parent["Left Leg"])
		limbcollider.Size = Vector3.new(1,1.3,1)
		limbcollider.Shape = "Cylinder"
		limbcollider.Transparency = 1
		local limbcolliderweld = Instance.new("Weld", limbcollider)
		limbcolliderweld.Part0 = Humanoid.Parent["Left Leg"]
		limbcolliderweld.Part1 = limbcollider
		limbcolliderweld.C0 = CFrame.fromEulerAnglesXYZ(0,0,math.pi/2) * CFrame.new(-0.4,0,0)
	end
	if Humanoid.Parent:FindFirstChild("Right Leg") then
		local limbcollider = Instance.new("Part", Humanoid.Parent["Right Leg"])
		limbcollider.Size = Vector3.new(1,1.3,1)
		limbcollider.Shape = "Cylinder"
		limbcollider.Transparency = 1
		local limbcolliderweld = Instance.new("Weld", limbcollider)
		limbcolliderweld.Part0 = Humanoid.Parent["Right Leg"]
		limbcolliderweld.Part1 = limbcollider
		limbcolliderweld.C0 = CFrame.fromEulerAnglesXYZ(0,0,math.pi/2) * CFrame.new(-0.4,0,0)
	end
	local ragdoll = zombiecorpse
	if ragdoll:FindFirstChild("HumanoidRootPart") then
		ragdoll.HumanoidRootPart.CanCollide = false
		ragdoll.HumanoidRootPart:Destroy()
	end
end

Dummy.Humanoid.Died:connect(death)
Socket.on("LMS",function()
	lastmanstanding = true
end)
Dummy.Stun.Event:Connect(function()
	if ragedplayed then return end
	attacking = false
	throwing = false
	Stunned = true
	castTrack:Stop()
	casting = false
	local startAnim = Instance.new("Animation")
	startAnim.AnimationId = "rbxassetid://75387788824130"
	local loopAnim = Instance.new("Animation")
	loopAnim.AnimationId = "rbxassetid://123398976569641"
	local endAnim = Instance.new("Animation")
	endAnim.AnimationId = "rbxassetid://94565167215176"

	local startTrack = humanoid:LoadAnimation(startAnim)
	startTrack:AdjustSpeed(1.5)
	local loopTrack = humanoid:LoadAnimation(loopAnim)
	local endTrack = humanoid:LoadAnimation(endAnim)
	endTrack:AdjustSpeed(1.5)

	startTrack:Play()
	startTrack.Stopped:Wait()

	if Stunned then
		loopTrack:Play()
	end

	task.delay(3.5, function()
		if Stunned then
			if loopTrack.IsPlaying then
				loopTrack:Stop()
			end
			endTrack:Play()
			endTrack.Stopped:Wait()
			Stunned = false
		end
	end)
end)
